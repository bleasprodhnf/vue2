{"ast":null,"code":"// The reason for this strange abstraction is because we can't rely on\n// nested worker support (Safari doesn't support it). We need to proxy\n// creating a child worker through the main thread, and this requires\n// a bit of glue code. We don't want to duplicate this code in each\n// backend that needs it, so this module abstracts it out. It has to\n// have a strange shape because we don't want to eagerly bundle the\n// backend code, so users of this code need to pass an `() =>\n// import('worker.js')` expression to get the worker module to run.\n\nfunction isWorker() {\n  return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n}\nfunction makeStartWorkerFromMain(getModule) {\n  return (argBuffer, resultBuffer, parentWorker) => {\n    if (isWorker()) {\n      throw new Error('`startWorkerFromMain` should only be called from the main thread');\n    }\n    if (typeof Worker === 'undefined') {\n      // We're on the main thread? Weird: it doesn't have workers\n      throw new Error('Web workers not available. sqlite3 requires web workers to work.');\n    }\n    getModule().then(({\n      default: BackendWorker\n    }) => {\n      let worker = new BackendWorker();\n      worker.postMessage({\n        type: 'init',\n        buffers: [argBuffer, resultBuffer]\n      });\n      worker.addEventListener('message', msg => {\n        // Forward any messages to the worker that's supposed\n        // to be the parent\n        parentWorker.postMessage(msg.data);\n      });\n    });\n  };\n}\nfunction makeInitBackend(spawnEventName, getModule) {\n  const startWorkerFromMain = makeStartWorkerFromMain(getModule);\n  return worker => {\n    worker.addEventListener('message', e => {\n      switch (e.data.type) {\n        case spawnEventName:\n          startWorkerFromMain(e.data.argBuffer, e.data.resultBuffer, worker);\n          break;\n      }\n    });\n  };\n}\n\n// Use the generic main thread module to create our indexeddb worker\n// proxy\nconst initBackend = makeInitBackend('__absurd:spawn-idb-worker', () => import('./indexeddb-main-thread-worker-b24e7a21.js'));\nexport { initBackend };","map":{"version":3,"names":["isWorker","WorkerGlobalScope","self","makeStartWorkerFromMain","getModule","argBuffer","resultBuffer","parentWorker","Error","Worker","then","default","BackendWorker","worker","postMessage","type","buffers","addEventListener","msg","data","makeInitBackend","spawnEventName","startWorkerFromMain","e","initBackend"],"sources":["C:/ysx/xm/mark/web/node_modules/absurd-sql-optimized/dist/indexeddb-main-thread.js"],"sourcesContent":["// The reason for this strange abstraction is because we can't rely on\n// nested worker support (Safari doesn't support it). We need to proxy\n// creating a child worker through the main thread, and this requires\n// a bit of glue code. We don't want to duplicate this code in each\n// backend that needs it, so this module abstracts it out. It has to\n// have a strange shape because we don't want to eagerly bundle the\n// backend code, so users of this code need to pass an `() =>\n// import('worker.js')` expression to get the worker module to run.\n\nfunction isWorker() {\n  return (\n    typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope\n  );\n}\n\nfunction makeStartWorkerFromMain(getModule) {\n  return (argBuffer, resultBuffer, parentWorker) => {\n    if (isWorker()) {\n      throw new Error(\n        '`startWorkerFromMain` should only be called from the main thread'\n      );\n    }\n\n    if (typeof Worker === 'undefined') {\n      // We're on the main thread? Weird: it doesn't have workers\n      throw new Error(\n        'Web workers not available. sqlite3 requires web workers to work.'\n      );\n    }\n\n    getModule().then(({ default: BackendWorker }) => {\n      let worker = new BackendWorker();\n\n      worker.postMessage({ type: 'init', buffers: [argBuffer, resultBuffer] });\n\n      worker.addEventListener('message', msg => {\n        // Forward any messages to the worker that's supposed\n        // to be the parent\n        parentWorker.postMessage(msg.data);\n      });\n    });\n  };\n}\n\nfunction makeInitBackend(spawnEventName, getModule) {\n  const startWorkerFromMain = makeStartWorkerFromMain(getModule);\n\n  return worker => {\n    worker.addEventListener('message', e => {\n      switch (e.data.type) {\n        case spawnEventName:\n          startWorkerFromMain(e.data.argBuffer, e.data.resultBuffer, worker);\n          break;\n      }\n    });\n  };\n}\n\n// Use the generic main thread module to create our indexeddb worker\n// proxy\nconst initBackend = makeInitBackend('__absurd:spawn-idb-worker', () =>\n  import('./indexeddb-main-thread-worker-b24e7a21.js')\n);\n\nexport { initBackend };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,QAAQA,CAAA,EAAG;EAClB,OACE,OAAOC,iBAAiB,KAAK,WAAW,IACxCC,IAAI,YAAYD,iBAAiB;AAErC;AAEA,SAASE,uBAAuBA,CAACC,SAAS,EAAE;EAC1C,OAAO,CAACC,SAAS,EAAEC,YAAY,EAAEC,YAAY,KAAK;IAChD,IAAIP,QAAQ,CAAC,CAAC,EAAE;MACd,MAAM,IAAIQ,KAAK,CACb,kEACF,CAAC;IACH;IAEA,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;MACjC;MACA,MAAM,IAAID,KAAK,CACb,kEACF,CAAC;IACH;IAEAJ,SAAS,CAAC,CAAC,CAACM,IAAI,CAAC,CAAC;MAAEC,OAAO,EAAEC;IAAc,CAAC,KAAK;MAC/C,IAAIC,MAAM,GAAG,IAAID,aAAa,CAAC,CAAC;MAEhCC,MAAM,CAACC,WAAW,CAAC;QAAEC,IAAI,EAAE,MAAM;QAAEC,OAAO,EAAE,CAACX,SAAS,EAAEC,YAAY;MAAE,CAAC,CAAC;MAExEO,MAAM,CAACI,gBAAgB,CAAC,SAAS,EAAEC,GAAG,IAAI;QACxC;QACA;QACAX,YAAY,CAACO,WAAW,CAACI,GAAG,CAACC,IAAI,CAAC;MACpC,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC;AACH;AAEA,SAASC,eAAeA,CAACC,cAAc,EAAEjB,SAAS,EAAE;EAClD,MAAMkB,mBAAmB,GAAGnB,uBAAuB,CAACC,SAAS,CAAC;EAE9D,OAAOS,MAAM,IAAI;IACfA,MAAM,CAACI,gBAAgB,CAAC,SAAS,EAAEM,CAAC,IAAI;MACtC,QAAQA,CAAC,CAACJ,IAAI,CAACJ,IAAI;QACjB,KAAKM,cAAc;UACjBC,mBAAmB,CAACC,CAAC,CAACJ,IAAI,CAACd,SAAS,EAAEkB,CAAC,CAACJ,IAAI,CAACb,YAAY,EAAEO,MAAM,CAAC;UAClE;MACJ;IACF,CAAC,CAAC;EACJ,CAAC;AACH;;AAEA;AACA;AACA,MAAMW,WAAW,GAAGJ,eAAe,CAAC,2BAA2B,EAAE,MAC/D,MAAM,CAAC,4CAA4C,CACrD,CAAC;AAED,SAASI,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}