{"ast":null,"code":"import squel from 'squel';\nexport function localChatLogs(db) {\n  return db.exec(`\n      create table if not exists 'local_chat_logs' (\n        'client_msg_id' char(64),\n        'server_msg_id' char(64),\n        'send_id' char(64),\n        'recv_id' char(64),\n        'sender_platform_id' integer,\n        'sender_nick_name' varchar(255),\n        'sender_face_url' varchar(255),\n        'session_type' integer,\n        'msg_from' integer,\n        'content_type' integer,\n        'content' varchar(1000),\n        'is_read' numeric,\n        'is_react' numeric,\n        'is_external_extensions' numeric,\n        'msg_first_modify_time' integer,\n        'status' integer,\n        'seq' integer default 0,\n        'send_time' integer,\n        'create_time' integer,\n        'attached_info' varchar(1024),\n        'ex' varchar(1024),\n        primary key ('client_msg_id'))\n    `);\n}\nexport function getMessage(db, messageId) {\n  return db.exec(`\n      select * from 'local_chat_logs' where client_msg_id='${messageId}'\n    `);\n}\nexport function getMultipleMessage(db, msgIDList) {\n  const values = msgIDList.map(v => `'${v}'`).join(',');\n  return db.exec(`\n    SELECT * FROM local_chat_logs WHERE client_msg_id IN (${values}) ORDER BY send_time DESC\n    `);\n}\nexport function getSendingMessageList(db) {\n  return db.exec(`\n      select * from local_chat_logs where status = 1;\n    `);\n}\nexport function getNormalMsgSeq(db) {\n  return db.exec(`\n      select ifnull(max(seq),0) from local_chat_logs;\n    `);\n}\nexport function updateMessageTimeAndStatus(db, clientMsgID, serverMsgID, sendTime, status) {\n  return db.exec(`\n      update local_chat_logs set\n        server_msg_id='${serverMsgID}',\n        status=${status} ,\n        send_time=${sendTime}\n      where client_msg_id='${clientMsgID}' and seq=0;\n    `);\n}\nexport function updateMessage(db, clientMsgId, message) {\n  const sql = squel.update().table('local_chat_logs').setFields(message).where(`client_msg_id = '${clientMsgId}'`).toString();\n  return db.exec(sql);\n}\nexport function insertMessage(db, message) {\n  const sql = squel.insert().into('local_chat_logs').setFields(message).toString();\n  return db.exec(sql);\n}\nexport function batchInsertMessageList(db, messageList) {\n  const sql = squel.insert().into('local_chat_logs').setFieldsRows(messageList).toString();\n  return db.exec(sql);\n}\nexport function getMessageList(db, sourceID, sessionType, count, startTime, isReverse, loginUserID) {\n  const isSelf = loginUserID === sourceID;\n  const condition = isSelf ? `recv_id = \"${sourceID}\" and send_id = \"${sourceID}\"` : `(recv_id = \"${sourceID}\" or send_id = \"${sourceID}\")`;\n  return db.exec(`\n        select * from local_chat_logs\n        where\n            ${condition}\n            and status <= 3\n            and send_time ${isReverse ? '>' : '<'} ${startTime}\n            and session_type = ${sessionType}\n        order by send_time ${isReverse ? 'asc' : 'desc'}\n        limit ${count};    \n    `);\n}\nexport function getMessageListNoTime(db, sourceID, sessionType, count, isReverse, loginUserID) {\n  const isSelf = loginUserID === sourceID;\n  const condition = isSelf ? `recv_id = \"${sourceID}\" and send_id = \"${sourceID}\"` : `(recv_id = \"${sourceID}\" or send_id = \"${sourceID}\")`;\n  return db.exec(`\n        select * from local_chat_logs\n        where\n            ${condition}\n            and status <= 3\n            and session_type = ${sessionType}\n        order by send_time ${isReverse ? 'asc' : 'desc'}\n        limit ${count};    \n    `);\n}\nexport function messageIfExists(db, clientMsgID) {\n  return db.exec(`\n        select count(*) from local_chat_logs\n        where \n            client_msg_id = \"${clientMsgID}\";\n    `);\n}\nexport function messageIfExistsBySeq(db, seq) {\n  return db.exec(`\n        select count(*) from local_chat_logs\n        where \n            seq = ${seq};\n    `);\n}\nexport function searchMessageByKeyword(db, contentType, keywordList, keywordListMatchType, sourceID, startTime, endTime, sessionType, offset, count) {\n  const finalEndTime = endTime ? endTime : new Date().getTime();\n  const condition = sessionType !== 2 ? `(send_id==\"${sourceID}\" OR recv_id==\"${sourceID}\")` : `recv_id==\"${sourceID}\"`;\n  let subCondition = '';\n  const values = contentType.map(v => `${v}`).join(',');\n  const connectStr = keywordListMatchType === 0 ? 'or ' : 'and ';\n  keywordList.forEach((keyword, index) => {\n    if (index == 0) {\n      subCondition += 'And (';\n    }\n    if (index + 1 >= keywordList.length) {\n      subCondition += 'content like ' + \"'%\" + keywordList[index] + \"%') \";\n    } else {\n      subCondition += 'content like ' + \"'%\" + keywordList[index] + \"%' \" + connectStr;\n    }\n  });\n  return db.exec(`  \n    SELECT * FROM local_chat_logs \n          WHERE session_type==${sessionType}\n          And ${condition}\n          And send_time  between ${startTime} and ${finalEndTime} \n          AND status <=3  \n          And content_type IN (${values}) \n          ${subCondition}\n    ORDER BY send_time DESC LIMIT ${count} OFFSET ${offset};\n    `);\n}\nexport function searchMessageByContentType(db, contentType, sourceID, startTime, endTime, sessionType, offset, count) {\n  const values = contentType.map(v => `${v}`).join(',');\n  const finalEndTime = endTime ? endTime : new Date().getTime();\n  const condition = sessionType !== 2 ? `(send_id==\"${sourceID}\" OR recv_id==\"${sourceID}\")` : `recv_id==\"${sourceID}\"`;\n  return db.exec(`  \n    SELECT * FROM local_chat_logs \n          WHERE session_type==${sessionType}\n          And ${condition}\n          And send_time between ${startTime} and ${finalEndTime} \n          AND status <=3 \n          And content_type IN (${values}) \n    ORDER BY send_time DESC LIMIT ${count} OFFSET ${offset};\n    `);\n}\nexport function searchMessageByContentTypeAndKeyword(db, contentType, keywordList, keywordListMatchType, startTime, endTime) {\n  const values = contentType.map(v => `${v}`).join(',');\n  const finalEndTime = endTime ? endTime : new Date().getTime();\n  let subCondition = '';\n  const connectStr = keywordListMatchType === 0 ? 'or ' : 'and ';\n  keywordList.forEach((keyword, index) => {\n    if (index == 0) {\n      subCondition += 'And (';\n    }\n    if (index + 1 >= keywordList.length) {\n      subCondition += 'content like ' + \"'%\" + keywordList[index] + \"%') \";\n    } else {\n      subCondition += 'content like ' + \"'%\" + keywordList[index] + \"%' \" + connectStr;\n    }\n  });\n  return db.exec(`  \n    SELECT * FROM local_chat_logs \n          WHERE send_time between ${startTime} and ${finalEndTime}\n          AND status <=3  \n          And content_type IN (${values})\n          ${subCondition}\n    ORDER BY send_time DESC\n    `);\n}\nexport function updateMsgSenderNickname(db, sendID, nickname, sessionType) {\n  return db.exec(`  \n    UPDATE local_chat_logs \n          SET sender_nick_name=\"${nickname}\" \n          WHERE send_id = \"${sendID}\" \n          and session_type = ${sessionType}\n          and sender_nick_name != \"${nickname}\"\n    `);\n}\nexport function updateMsgSenderFaceURL(db, sendID, faceURL, sessionType) {\n  return db.exec(`  \n    UPDATE local_chat_logs \n          SET sender_face_url=\"${faceURL}\" \n          WHERE send_id = \"${sendID}\" \n          and session_type = ${sessionType}\n          and sender_face_url != \"${faceURL}\"\n    `);\n}\nexport function updateMsgSenderFaceURLAndSenderNickname(db, sendID, faceURL, nickname, sessionType) {\n  return db.exec(`  \n    UPDATE local_chat_logs \n          SET sender_face_url=\"${faceURL}\",sender_nick_name=\"${nickname}\" \n          WHERE send_id = \"${sendID}\" \n          and session_type = ${sessionType}\n    `);\n}\nexport function getMsgSeqByClientMsgID(db, clientMsgID) {\n  return db.exec(`  \n    SELECT seq FROM local_chat_logs \n    WHERE client_msg_id=\"${clientMsgID}\" \n    LIMIT 1\n    `);\n}\nexport function getMsgSeqListByGroupID(db, groupID) {\n  return db.exec(`  \n    SELECT seq FROM local_chat_logs \n    WHERE recv_id=\"${groupID}\"\n    `);\n}\nexport function getMsgSeqListByPeerUserID(db, userID) {\n  return db.exec(`  \n    SELECT seq FROM local_chat_logs \n    WHERE recv_id=\"${userID}\" \n    or send_id=\"${userID}\"\n    `);\n}\nexport function getMsgSeqListBySelfUserID(db, userID) {\n  return db.exec(`  \n    SELECT seq FROM local_chat_logs \n    WHERE recv_id=\"${userID}\" \n    and send_id=\"${userID}\"\n    `);\n}\nexport function deleteAllMessage(db) {\n  return db.exec(`  \n    UPDATE local_chat_logs SET content=\"\",status=4\n    `);\n}\nexport function getAllUnDeleteMessageSeqList(db) {\n  return db.exec(`  \n    SELECT seq FROM local_chat_logs WHERE status != 4\n    `);\n}\nexport function updateSingleMessageHasRead(db, sendID, clientMsgIDList) {\n  const values = clientMsgIDList.map(v => `'${v}'`).join(',');\n  return db.exec(`  \n    UPDATE local_chat_logs SET is_read=1 \n    WHERE send_id=\"${sendID}\"  \n    AND session_type=1 \n    AND client_msg_id in (${values})\n    `);\n}\nexport function updateGroupMessageHasRead(db, clientMsgIDList, sessionType) {\n  const values = clientMsgIDList.map(v => `'${v}'`).join(',');\n  return db.exec(`\n        update local_chat_logs\n        set is_read =1\n        where session_type=${sessionType}\n            and client_msg_id in (${values})\n\n    `);\n}\nexport function updateMessageStatusBySourceID(db, sourceID, status, sessionType, loginUserID) {\n  let condition = `(send_id= \"${sourceID}\" or recv_id=\"${sourceID}\")`;\n  if (sessionType === 1 && sourceID === loginUserID) {\n    condition = `send_id= \"${sourceID}\" AND recv_id=\"${sourceID}\"`;\n  }\n  return db.exec(`\n        update local_chat_logs\n        set status=${status}\n        where session_type=${sessionType}\n        AND ${condition}\n    `);\n}","map":{"version":3,"names":["squel","localChatLogs","db","exec","getMessage","messageId","getMultipleMessage","msgIDList","values","map","v","join","getSendingMessageList","getNormalMsgSeq","updateMessageTimeAndStatus","clientMsgID","serverMsgID","sendTime","status","updateMessage","clientMsgId","message","sql","update","table","setFields","where","toString","insertMessage","insert","into","batchInsertMessageList","messageList","setFieldsRows","getMessageList","sourceID","sessionType","count","startTime","isReverse","loginUserID","isSelf","condition","getMessageListNoTime","messageIfExists","messageIfExistsBySeq","seq","searchMessageByKeyword","contentType","keywordList","keywordListMatchType","endTime","offset","finalEndTime","Date","getTime","subCondition","connectStr","forEach","keyword","index","length","searchMessageByContentType","searchMessageByContentTypeAndKeyword","updateMsgSenderNickname","sendID","nickname","updateMsgSenderFaceURL","faceURL","updateMsgSenderFaceURLAndSenderNickname","getMsgSeqByClientMsgID","getMsgSeqListByGroupID","groupID","getMsgSeqListByPeerUserID","userID","getMsgSeqListBySelfUserID","deleteAllMessage","getAllUnDeleteMessageSeqList","updateSingleMessageHasRead","clientMsgIDList","updateGroupMessageHasRead","updateMessageStatusBySourceID"],"sources":["C:/ysx/xm/mark/web/src/utils/lib/sqls/localChatLogs.js"],"sourcesContent":["import squel from 'squel';\nexport function localChatLogs(db) {\n    return db.exec(`\n      create table if not exists 'local_chat_logs' (\n        'client_msg_id' char(64),\n        'server_msg_id' char(64),\n        'send_id' char(64),\n        'recv_id' char(64),\n        'sender_platform_id' integer,\n        'sender_nick_name' varchar(255),\n        'sender_face_url' varchar(255),\n        'session_type' integer,\n        'msg_from' integer,\n        'content_type' integer,\n        'content' varchar(1000),\n        'is_read' numeric,\n        'is_react' numeric,\n        'is_external_extensions' numeric,\n        'msg_first_modify_time' integer,\n        'status' integer,\n        'seq' integer default 0,\n        'send_time' integer,\n        'create_time' integer,\n        'attached_info' varchar(1024),\n        'ex' varchar(1024),\n        primary key ('client_msg_id'))\n    `);\n}\nexport function getMessage(db, messageId) {\n    return db.exec(`\n      select * from 'local_chat_logs' where client_msg_id='${messageId}'\n    `);\n}\nexport function getMultipleMessage(db, msgIDList) {\n    const values = msgIDList.map(v => `'${v}'`).join(',');\n    return db.exec(`\n    SELECT * FROM local_chat_logs WHERE client_msg_id IN (${values}) ORDER BY send_time DESC\n    `);\n}\nexport function getSendingMessageList(db) {\n    return db.exec(`\n      select * from local_chat_logs where status = 1;\n    `);\n}\nexport function getNormalMsgSeq(db) {\n    return db.exec(`\n      select ifnull(max(seq),0) from local_chat_logs;\n    `);\n}\nexport function updateMessageTimeAndStatus(db, clientMsgID, serverMsgID, sendTime, status) {\n    return db.exec(`\n      update local_chat_logs set\n        server_msg_id='${serverMsgID}',\n        status=${status} ,\n        send_time=${sendTime}\n      where client_msg_id='${clientMsgID}' and seq=0;\n    `);\n}\nexport function updateMessage(db, clientMsgId, message) {\n    const sql = squel\n        .update()\n        .table('local_chat_logs')\n        .setFields(message)\n        .where(`client_msg_id = '${clientMsgId}'`)\n        .toString();\n    return db.exec(sql);\n}\nexport function insertMessage(db, message) {\n    const sql = squel\n        .insert()\n        .into('local_chat_logs')\n        .setFields(message)\n        .toString();\n    return db.exec(sql);\n}\nexport function batchInsertMessageList(db, messageList) {\n    const sql = squel\n        .insert()\n        .into('local_chat_logs')\n        .setFieldsRows(messageList)\n        .toString();\n    return db.exec(sql);\n}\nexport function getMessageList(db, sourceID, sessionType, count, startTime, isReverse, loginUserID) {\n    const isSelf = loginUserID === sourceID;\n    const condition = isSelf\n        ? `recv_id = \"${sourceID}\" and send_id = \"${sourceID}\"`\n        : `(recv_id = \"${sourceID}\" or send_id = \"${sourceID}\")`;\n    return db.exec(`\n        select * from local_chat_logs\n        where\n            ${condition}\n            and status <= 3\n            and send_time ${isReverse ? '>' : '<'} ${startTime}\n            and session_type = ${sessionType}\n        order by send_time ${isReverse ? 'asc' : 'desc'}\n        limit ${count};    \n    `);\n}\nexport function getMessageListNoTime(db, sourceID, sessionType, count, isReverse, loginUserID) {\n    const isSelf = loginUserID === sourceID;\n    const condition = isSelf\n        ? `recv_id = \"${sourceID}\" and send_id = \"${sourceID}\"`\n        : `(recv_id = \"${sourceID}\" or send_id = \"${sourceID}\")`;\n    return db.exec(`\n        select * from local_chat_logs\n        where\n            ${condition}\n            and status <= 3\n            and session_type = ${sessionType}\n        order by send_time ${isReverse ? 'asc' : 'desc'}\n        limit ${count};    \n    `);\n}\nexport function messageIfExists(db, clientMsgID) {\n    return db.exec(`\n        select count(*) from local_chat_logs\n        where \n            client_msg_id = \"${clientMsgID}\";\n    `);\n}\nexport function messageIfExistsBySeq(db, seq) {\n    return db.exec(`\n        select count(*) from local_chat_logs\n        where \n            seq = ${seq};\n    `);\n}\nexport function searchMessageByKeyword(db, contentType, keywordList, keywordListMatchType, sourceID, startTime, endTime, sessionType, offset, count) {\n    const finalEndTime = endTime ? endTime : new Date().getTime();\n    const condition = sessionType !== 2\n        ? `(send_id==\"${sourceID}\" OR recv_id==\"${sourceID}\")`\n        : `recv_id==\"${sourceID}\"`;\n    let subCondition = '';\n    const values = contentType.map(v => `${v}`).join(',');\n    const connectStr = keywordListMatchType === 0 ? 'or ' : 'and ';\n    keywordList.forEach((keyword, index) => {\n        if (index == 0) {\n            subCondition += 'And (';\n        }\n        if (index + 1 >= keywordList.length) {\n            subCondition += 'content like ' + \"'%\" + keywordList[index] + \"%') \";\n        }\n        else {\n            subCondition +=\n                'content like ' + \"'%\" + keywordList[index] + \"%' \" + connectStr;\n        }\n    });\n    return db.exec(`  \n    SELECT * FROM local_chat_logs \n          WHERE session_type==${sessionType}\n          And ${condition}\n          And send_time  between ${startTime} and ${finalEndTime} \n          AND status <=3  \n          And content_type IN (${values}) \n          ${subCondition}\n    ORDER BY send_time DESC LIMIT ${count} OFFSET ${offset};\n    `);\n}\nexport function searchMessageByContentType(db, contentType, sourceID, startTime, endTime, sessionType, offset, count) {\n    const values = contentType.map(v => `${v}`).join(',');\n    const finalEndTime = endTime ? endTime : new Date().getTime();\n    const condition = sessionType !== 2\n        ? `(send_id==\"${sourceID}\" OR recv_id==\"${sourceID}\")`\n        : `recv_id==\"${sourceID}\"`;\n    return db.exec(`  \n    SELECT * FROM local_chat_logs \n          WHERE session_type==${sessionType}\n          And ${condition}\n          And send_time between ${startTime} and ${finalEndTime} \n          AND status <=3 \n          And content_type IN (${values}) \n    ORDER BY send_time DESC LIMIT ${count} OFFSET ${offset};\n    `);\n}\nexport function searchMessageByContentTypeAndKeyword(db, contentType, keywordList, keywordListMatchType, startTime, endTime) {\n    const values = contentType.map(v => `${v}`).join(',');\n    const finalEndTime = endTime ? endTime : new Date().getTime();\n    let subCondition = '';\n    const connectStr = keywordListMatchType === 0 ? 'or ' : 'and ';\n    keywordList.forEach((keyword, index) => {\n        if (index == 0) {\n            subCondition += 'And (';\n        }\n        if (index + 1 >= keywordList.length) {\n            subCondition += 'content like ' + \"'%\" + keywordList[index] + \"%') \";\n        }\n        else {\n            subCondition +=\n                'content like ' + \"'%\" + keywordList[index] + \"%' \" + connectStr;\n        }\n    });\n    return db.exec(`  \n    SELECT * FROM local_chat_logs \n          WHERE send_time between ${startTime} and ${finalEndTime}\n          AND status <=3  \n          And content_type IN (${values})\n          ${subCondition}\n    ORDER BY send_time DESC\n    `);\n}\nexport function updateMsgSenderNickname(db, sendID, nickname, sessionType) {\n    return db.exec(`  \n    UPDATE local_chat_logs \n          SET sender_nick_name=\"${nickname}\" \n          WHERE send_id = \"${sendID}\" \n          and session_type = ${sessionType}\n          and sender_nick_name != \"${nickname}\"\n    `);\n}\nexport function updateMsgSenderFaceURL(db, sendID, faceURL, sessionType) {\n    return db.exec(`  \n    UPDATE local_chat_logs \n          SET sender_face_url=\"${faceURL}\" \n          WHERE send_id = \"${sendID}\" \n          and session_type = ${sessionType}\n          and sender_face_url != \"${faceURL}\"\n    `);\n}\nexport function updateMsgSenderFaceURLAndSenderNickname(db, sendID, faceURL, nickname, sessionType) {\n    return db.exec(`  \n    UPDATE local_chat_logs \n          SET sender_face_url=\"${faceURL}\",sender_nick_name=\"${nickname}\" \n          WHERE send_id = \"${sendID}\" \n          and session_type = ${sessionType}\n    `);\n}\nexport function getMsgSeqByClientMsgID(db, clientMsgID) {\n    return db.exec(`  \n    SELECT seq FROM local_chat_logs \n    WHERE client_msg_id=\"${clientMsgID}\" \n    LIMIT 1\n    `);\n}\nexport function getMsgSeqListByGroupID(db, groupID) {\n    return db.exec(`  \n    SELECT seq FROM local_chat_logs \n    WHERE recv_id=\"${groupID}\"\n    `);\n}\nexport function getMsgSeqListByPeerUserID(db, userID) {\n    return db.exec(`  \n    SELECT seq FROM local_chat_logs \n    WHERE recv_id=\"${userID}\" \n    or send_id=\"${userID}\"\n    `);\n}\nexport function getMsgSeqListBySelfUserID(db, userID) {\n    return db.exec(`  \n    SELECT seq FROM local_chat_logs \n    WHERE recv_id=\"${userID}\" \n    and send_id=\"${userID}\"\n    `);\n}\nexport function deleteAllMessage(db) {\n    return db.exec(`  \n    UPDATE local_chat_logs SET content=\"\",status=4\n    `);\n}\nexport function getAllUnDeleteMessageSeqList(db) {\n    return db.exec(`  \n    SELECT seq FROM local_chat_logs WHERE status != 4\n    `);\n}\nexport function updateSingleMessageHasRead(db, sendID, clientMsgIDList) {\n    const values = clientMsgIDList.map(v => `'${v}'`).join(',');\n    return db.exec(`  \n    UPDATE local_chat_logs SET is_read=1 \n    WHERE send_id=\"${sendID}\"  \n    AND session_type=1 \n    AND client_msg_id in (${values})\n    `);\n}\nexport function updateGroupMessageHasRead(db, clientMsgIDList, sessionType) {\n    const values = clientMsgIDList.map(v => `'${v}'`).join(',');\n    return db.exec(`\n        update local_chat_logs\n        set is_read =1\n        where session_type=${sessionType}\n            and client_msg_id in (${values})\n\n    `);\n}\nexport function updateMessageStatusBySourceID(db, sourceID, status, sessionType, loginUserID) {\n    let condition = `(send_id= \"${sourceID}\" or recv_id=\"${sourceID}\")`;\n    if (sessionType === 1 && sourceID === loginUserID) {\n        condition = `send_id= \"${sourceID}\" AND recv_id=\"${sourceID}\"`;\n    }\n    return db.exec(`\n        update local_chat_logs\n        set status=${status}\n        where session_type=${sessionType}\n        AND ${condition}\n    `);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}