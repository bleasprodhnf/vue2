{"ast":null,"code":"const ERRNO_CODES = {\n  EPERM: 63,\n  ENOENT: 44\n};\n\n// This implements an emscripten-compatible filesystem that is means\n// to be mounted to the one from `sql.js`. Example:\n//\n// let BFS = new SQLiteFS(SQL.FS, idbBackend);\n// SQL.FS.mount(BFS, {}, '/blocked');\n//\n// Now any files created under '/blocked' will be handled by this\n// filesystem, which creates a special file that handles read/writes\n// in the way that we want.\nclass SQLiteFS$1 {\n  constructor(FS, backend) {\n    this.FS = FS;\n    this.backend = backend;\n    this.node_ops = {\n      getattr: node => {\n        let fileattr = FS.isFile(node.mode) ? node.contents.getattr() : null;\n        let attr = {};\n        attr.dev = 1;\n        attr.ino = node.id;\n        attr.mode = fileattr ? fileattr.mode : node.mode;\n        attr.nlink = 1;\n        attr.uid = 0;\n        attr.gid = 0;\n        attr.rdev = node.rdev;\n        attr.size = fileattr ? fileattr.size : FS.isDir(node.mode) ? 4096 : 0;\n        attr.atime = new Date(0);\n        attr.mtime = new Date(0);\n        attr.ctime = new Date(0);\n        attr.blksize = fileattr ? fileattr.blockSize : 4096;\n        attr.blocks = Math.ceil(attr.size / attr.blksize);\n        return attr;\n      },\n      setattr: (node, attr) => {\n        if (this.FS.isFile(node.mode)) {\n          node.contents.setattr(attr);\n        } else {\n          if (attr.mode != null) {\n            node.mode = attr.mode;\n          }\n          if (attr.size != null) {\n            node.size = attr.size;\n          }\n        }\n      },\n      lookup: (parent, name) => {\n        throw new this.FS.ErrnoError(ERRNO_CODES.ENOENT);\n      },\n      mknod: (parent, name, mode, dev) => {\n        if (name.endsWith('.lock')) {\n          throw new Error('Locking via lockfiles is not supported');\n        }\n        return this.createNode(parent, name, mode, dev);\n      },\n      rename: (old_node, new_dir, new_name) => {\n        throw new Error('rename not implemented');\n      },\n      unlink: (parent, name) => {\n        let node = this.FS.lookupNode(parent, name);\n        node.contents.delete(name);\n      },\n      readdir: node => {\n        // We could list all the available databases here if `node` is\n        // the root directory. However Firefox does not implemented\n        // such a methods. Other browsers do, but since it's not\n        // supported on all browsers users will need to track it\n        // separate anyway right now\n\n        throw new Error('readdir not implemented');\n      },\n      symlink: (parent, newname, oldpath) => {\n        throw new Error('symlink not implemented');\n      },\n      readlink: node => {\n        throw new Error('symlink not implemented');\n      }\n    };\n    this.stream_ops = {\n      open: stream => {\n        if (this.FS.isFile(stream.node.mode)) {\n          stream.node.contents.open();\n        }\n      },\n      close: stream => {\n        if (this.FS.isFile(stream.node.mode)) {\n          stream.node.contents.close();\n        }\n      },\n      read: (stream, buffer, offset, length, position) => {\n        // console.log('read', offset, length, position)\n        return stream.node.contents.read(buffer, offset, length, position);\n      },\n      write: (stream, buffer, offset, length, position) => {\n        // console.log('write', offset, length, position);\n        return stream.node.contents.write(buffer, offset, length, position);\n      },\n      llseek: (stream, offset, whence) => {\n        // Copied from MEMFS\n        var position = offset;\n        if (whence === 1) {\n          position += stream.position;\n        } else if (whence === 2) {\n          if (FS.isFile(stream.node.mode)) {\n            position += stream.node.contents.getattr().size;\n          }\n        }\n        if (position < 0) {\n          throw new this.FS.ErrnoError(28);\n        }\n        return position;\n      },\n      allocate: (stream, offset, length) => {\n        stream.node.contents.setattr({\n          size: offset + length\n        });\n      },\n      mmap: (stream, address, length, position, prot, flags) => {\n        throw new Error('mmap not implemented');\n      },\n      msync: (stream, buffer, offset, length, mmapFlags) => {\n        throw new Error('msync not implemented');\n      },\n      fsync: (stream, buffer, offset, length, mmapFlags) => {\n        stream.node.contents.fsync();\n      }\n    };\n  }\n  mount() {\n    return this.createNode(null, '/', 16384 /* dir */ | 511 /* 0777 */, 0);\n  }\n  lock(path, lockType) {\n    let {\n      node\n    } = this.FS.lookupPath(path);\n    return node.contents.lock(lockType);\n  }\n  unlock(path, lockType) {\n    let {\n      node\n    } = this.FS.lookupPath(path);\n    return node.contents.unlock(lockType);\n  }\n  createNode(parent, name, mode, dev) {\n    // Only files and directories supported\n    if (!(this.FS.isDir(mode) || this.FS.isFile(mode))) {\n      throw new this.FS.ErrnoError(ERRNO_CODES.EPERM);\n    }\n    var node = this.FS.createNode(parent, name, mode, dev);\n    if (this.FS.isDir(node.mode)) {\n      node.node_ops = {\n        mknod: this.node_ops.mknod,\n        lookup: this.node_ops.lookup,\n        unlink: this.node_ops.unlink,\n        setattr: this.node_ops.setattr\n      };\n      node.stream_ops = {};\n      node.contents = {};\n    } else if (this.FS.isFile(node.mode)) {\n      node.node_ops = this.node_ops;\n      node.stream_ops = this.stream_ops;\n\n      // Create file!\n      node.contents = this.backend.createFile(name);\n    }\n\n    // add the new node to the parent\n    if (parent) {\n      parent.contents[name] = node;\n      parent.timestamp = node.timestamp;\n    }\n    return node;\n  }\n}\n\n// Right now we don't support `export from` so we do this manually\nconst SQLiteFS = SQLiteFS$1;\nexport { SQLiteFS };","map":{"version":3,"names":["ERRNO_CODES","EPERM","ENOENT","SQLiteFS$1","constructor","FS","backend","node_ops","getattr","node","fileattr","isFile","mode","contents","attr","dev","ino","id","nlink","uid","gid","rdev","size","isDir","atime","Date","mtime","ctime","blksize","blockSize","blocks","Math","ceil","setattr","lookup","parent","name","ErrnoError","mknod","endsWith","Error","createNode","rename","old_node","new_dir","new_name","unlink","lookupNode","delete","readdir","symlink","newname","oldpath","readlink","stream_ops","open","stream","close","read","buffer","offset","length","position","write","llseek","whence","allocate","mmap","address","prot","flags","msync","mmapFlags","fsync","mount","lock","path","lockType","lookupPath","unlock","createFile","timestamp","SQLiteFS"],"sources":["C:/ysx/xm/mark/web/node_modules/absurd-sql-optimized/dist/index.js"],"sourcesContent":["const ERRNO_CODES = {\n  EPERM: 63,\n  ENOENT: 44\n};\n\n// This implements an emscripten-compatible filesystem that is means\n// to be mounted to the one from `sql.js`. Example:\n//\n// let BFS = new SQLiteFS(SQL.FS, idbBackend);\n// SQL.FS.mount(BFS, {}, '/blocked');\n//\n// Now any files created under '/blocked' will be handled by this\n// filesystem, which creates a special file that handles read/writes\n// in the way that we want.\nclass SQLiteFS$1 {\n  constructor(FS, backend) {\n    this.FS = FS;\n    this.backend = backend;\n\n    this.node_ops = {\n      getattr: node => {\n        let fileattr = FS.isFile(node.mode) ? node.contents.getattr() : null;\n\n        let attr = {};\n        attr.dev = 1;\n        attr.ino = node.id;\n        attr.mode = fileattr ? fileattr.mode : node.mode;\n        attr.nlink = 1;\n        attr.uid = 0;\n        attr.gid = 0;\n        attr.rdev = node.rdev;\n        attr.size = fileattr ? fileattr.size : FS.isDir(node.mode) ? 4096 : 0;\n        attr.atime = new Date(0);\n        attr.mtime = new Date(0);\n        attr.ctime = new Date(0);\n        attr.blksize = fileattr ? fileattr.blockSize : 4096;\n        attr.blocks = Math.ceil(attr.size / attr.blksize);\n        return attr;\n      },\n      setattr: (node, attr) => {\n        if (this.FS.isFile(node.mode)) {\n          node.contents.setattr(attr);\n        } else {\n          if (attr.mode != null) {\n            node.mode = attr.mode;\n          }\n          if (attr.size != null) {\n            node.size = attr.size;\n          }\n        }\n      },\n      lookup: (parent, name) => {\n        throw new this.FS.ErrnoError(ERRNO_CODES.ENOENT);\n      },\n      mknod: (parent, name, mode, dev) => {\n        if (name.endsWith('.lock')) {\n          throw new Error('Locking via lockfiles is not supported');\n        }\n\n        return this.createNode(parent, name, mode, dev);\n      },\n      rename: (old_node, new_dir, new_name) => {\n        throw new Error('rename not implemented');\n      },\n      unlink: (parent, name) => {\n        let node = this.FS.lookupNode(parent, name);\n        node.contents.delete(name);\n      },\n      readdir: node => {\n        // We could list all the available databases here if `node` is\n        // the root directory. However Firefox does not implemented\n        // such a methods. Other browsers do, but since it's not\n        // supported on all browsers users will need to track it\n        // separate anyway right now\n\n        throw new Error('readdir not implemented');\n      },\n      symlink: (parent, newname, oldpath) => {\n        throw new Error('symlink not implemented');\n      },\n      readlink: node => {\n        throw new Error('symlink not implemented');\n      }\n    };\n\n    this.stream_ops = {\n      open: stream => {\n        if (this.FS.isFile(stream.node.mode)) {\n          stream.node.contents.open();\n        }\n      },\n\n      close: stream => {\n        if (this.FS.isFile(stream.node.mode)) {\n          stream.node.contents.close();\n        }\n      },\n\n      read: (stream, buffer, offset, length, position) => {\n        // console.log('read', offset, length, position)\n        return stream.node.contents.read(buffer, offset, length, position);\n      },\n\n      write: (stream, buffer, offset, length, position) => {\n        // console.log('write', offset, length, position);\n        return stream.node.contents.write(buffer, offset, length, position);\n      },\n\n      llseek: (stream, offset, whence) => {\n        // Copied from MEMFS\n        var position = offset;\n        if (whence === 1) {\n          position += stream.position;\n        } else if (whence === 2) {\n          if (FS.isFile(stream.node.mode)) {\n            position += stream.node.contents.getattr().size;\n          }\n        }\n        if (position < 0) {\n          throw new this.FS.ErrnoError(28);\n        }\n        return position;\n      },\n      allocate: (stream, offset, length) => {\n        stream.node.contents.setattr({ size: offset + length });\n      },\n      mmap: (stream, address, length, position, prot, flags) => {\n        throw new Error('mmap not implemented');\n      },\n      msync: (stream, buffer, offset, length, mmapFlags) => {\n        throw new Error('msync not implemented');\n      },\n      fsync: (stream, buffer, offset, length, mmapFlags) => {\n        stream.node.contents.fsync();\n      }\n    };\n  }\n\n  mount() {\n    return this.createNode(null, '/', 16384 /* dir */ | 511 /* 0777 */, 0);\n  }\n\n  lock(path, lockType) {\n    let { node } = this.FS.lookupPath(path);\n    return node.contents.lock(lockType);\n  }\n\n  unlock(path, lockType) {\n    let { node } = this.FS.lookupPath(path);\n    return node.contents.unlock(lockType);\n  }\n\n  createNode(parent, name, mode, dev) {\n    // Only files and directories supported\n    if (!(this.FS.isDir(mode) || this.FS.isFile(mode))) {\n      throw new this.FS.ErrnoError(ERRNO_CODES.EPERM);\n    }\n\n    var node = this.FS.createNode(parent, name, mode, dev);\n    if (this.FS.isDir(node.mode)) {\n      node.node_ops = {\n        mknod: this.node_ops.mknod,\n        lookup: this.node_ops.lookup,\n        unlink: this.node_ops.unlink,\n        setattr: this.node_ops.setattr\n      };\n      node.stream_ops = {};\n      node.contents = {};\n    } else if (this.FS.isFile(node.mode)) {\n      node.node_ops = this.node_ops;\n      node.stream_ops = this.stream_ops;\n\n      // Create file!\n      node.contents = this.backend.createFile(name);\n    }\n\n    // add the new node to the parent\n    if (parent) {\n      parent.contents[name] = node;\n      parent.timestamp = node.timestamp;\n    }\n\n    return node;\n  }\n}\n\n// Right now we don't support `export from` so we do this manually\nconst SQLiteFS = SQLiteFS$1;\n\nexport { SQLiteFS };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}