{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nlet LOCK_TYPES = {\n  NONE: 0,\n  SHARED: 1,\n  RESERVED: 2,\n  PENDING: 3,\n  EXCLUSIVE: 4\n};\nfunction getPageSize(bufferView) {\n  // See 1.3.2 on https://www.sqlite.org/fileformat.html The page size\n  // is stored as a 2 byte integer at the 16th byte. It's stored as\n  // big-endian so the first byte is the larger one. Combine it into a\n  // single integer.\n  let int1 = bufferView[16];\n  let int2 = bufferView[17];\n  return (int1 << 8) + int2;\n}\nfunction isSafeToWrite(localData, diskData) {\n  if (localData != null && diskData != null) {\n    let localView = new Uint8Array(localData);\n    let diskView = new Uint8Array(diskData);\n\n    // See\n    // https://github.com/sqlite/sqlite/blob/master/src/pager.c#L93-L96\n    // (might be documented somewhere? I didn't see it this clearly in\n    // the docs). At least one of these bytes change when sqlite3 writes\n    // data. We can check this against our in-memory data to see if it's\n    // safe to write (if something changes underneath us, it's not)\n    for (let i = 24; i < 40; i++) {\n      if (localView[i] !== diskView[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // One of them is null, so it's only safe if to write if both are\n  // null, otherwise they are different\n  return localData == null && diskData == null;\n}\nfunction range(start, end, step) {\n  let r = [];\n  for (let i = start; i <= end; i += step) {\n    r.push(i);\n  }\n  return r;\n}\nfunction getBoundaryIndexes(blockSize, start, end) {\n  let startC = start - start % blockSize;\n  let endC = end - 1 - (end - 1) % blockSize;\n  return range(startC, endC, blockSize);\n}\nfunction readChunks(chunks, start, end) {\n  let buffer = new ArrayBuffer(end - start);\n  let bufferView = new Uint8Array(buffer);\n  for (let i = 0; i < chunks.length; i++) {\n    let chunk = chunks[i];\n\n    // TODO: jest has a bug where we can't do `instanceof ArrayBuffer`\n    if (chunk.data.constructor.name !== 'ArrayBuffer') {\n      throw new Error('Chunk data is not an ArrayBuffer');\n    }\n    let cstart = 0;\n    let cend = chunk.data.byteLength;\n    if (start > chunk.pos) {\n      cstart = start - chunk.pos;\n    }\n    if (end < chunk.pos + chunk.data.byteLength) {\n      cend = end - chunk.pos;\n    }\n    if (cstart > chunk.data.byteLength || cend < 0) {\n      continue;\n    }\n    let len = cend - cstart;\n    bufferView.set(new Uint8Array(chunk.data, cstart, len), chunk.pos - start + cstart);\n  }\n  return buffer;\n}\nfunction writeChunks(bufferView, blockSize, start, end) {\n  let indexes = getBoundaryIndexes(blockSize, start, end);\n  let cursor = 0;\n  return indexes.map(index => {\n    let cstart = 0;\n    let cend = blockSize;\n    if (start > index && start < index + blockSize) {\n      cstart = start - index;\n    }\n    if (end > index && end < index + blockSize) {\n      cend = end - index;\n    }\n    let len = cend - cstart;\n    let chunkBuffer = new ArrayBuffer(blockSize);\n    if (start > index + blockSize || end <= index) {\n      return null;\n    }\n    let off = bufferView.byteOffset + cursor;\n    let available = bufferView.buffer.byteLength - off;\n    if (available <= 0) {\n      return null;\n    }\n    let readLength = Math.min(len, available);\n    new Uint8Array(chunkBuffer).set(new Uint8Array(bufferView.buffer, off, readLength), cstart);\n    cursor += readLength;\n    return {\n      pos: index,\n      data: chunkBuffer,\n      offset: cstart,\n      length: readLength\n    };\n  }).filter(Boolean);\n}\nclass File {\n  constructor(filename, ops, meta = null) {\n    this.filename = filename;\n    this.buffer = new Map();\n    this.ops = ops;\n    this.meta = meta;\n    this._metaDirty = false;\n    this.writeLock = false;\n    this.openHandles = 0;\n  }\n  bufferChunks(chunks) {\n    for (let i = 0; i < chunks.length; i++) {\n      let chunk = chunks[i];\n      this.buffer.set(chunk.pos, chunk);\n    }\n  }\n  open() {\n    this.openHandles++;\n\n    // Don't open the file again if it's already open\n    if (this.openHandles === 1) {\n      this.ops.open();\n      let meta = this.ops.readMeta();\n\n      // It's possible that `setattr` has already been called if opening\n      // the file in a mode that truncates it to 0\n      if (this.meta == null) {\n        if (meta == null) {\n          // New file\n\n          meta = {\n            size: 0\n          };\n        }\n        this.meta = meta;\n      }\n    }\n    return this.meta;\n  }\n  close() {\n    this.fsync();\n    this.openHandles = Math.max(this.openHandles - 1, 0);\n\n    // Only close it if there are no existing open handles\n    if (this.openHandles === 0) {\n      this.ops.close();\n    }\n  }\n  delete() {\n    this.ops.delete();\n  }\n  load(indexes) {\n    let status = indexes.reduce((acc, b) => {\n      let inMemory = this.buffer.get(b);\n      if (inMemory) {\n        acc.chunks.push(inMemory);\n      } else {\n        acc.missing.push(b);\n      }\n      return acc;\n    }, {\n      chunks: [],\n      missing: []\n    });\n    let missingChunks = [];\n    if (status.missing.length > 0) {\n      missingChunks = this.ops.readBlocks(status.missing, this.meta.blockSize);\n    }\n    return status.chunks.concat(missingChunks);\n  }\n  read(bufferView, offset, length, position) {\n    // console.log('reading', this.filename, offset, length, position);\n    let buffer = bufferView.buffer;\n    if (length <= 0) {\n      return 0;\n    }\n    if (position < 0) {\n      // TODO: is this right?\n      return 0;\n    }\n    if (position >= this.meta.size) {\n      let view = new Uint8Array(buffer, offset);\n      for (let i = 0; i < length; i++) {\n        view[i] = 0;\n      }\n      return length;\n    }\n    position = Math.max(position, 0);\n    let dataLength = Math.min(length, this.meta.size - position);\n    let start = position;\n    let end = position + dataLength;\n    let indexes = getBoundaryIndexes(this.meta.blockSize, start, end);\n    let chunks = this.load(indexes);\n    let readBuffer = readChunks(chunks, start, end);\n    if (buffer.byteLength - offset < readBuffer.byteLength) {\n      throw new Error('Buffer given to `read` is too small');\n    }\n    let view = new Uint8Array(buffer);\n    view.set(new Uint8Array(readBuffer), offset);\n\n    // TODO: I don't need to do this. `unixRead` does this for us.\n    for (let i = dataLength; i < length; i++) {\n      view[offset + i] = 0;\n    }\n    return length;\n  }\n  write(bufferView, offset, length, position) {\n    // console.log('writing', this.filename, offset, length, position);\n\n    if (this.meta.blockSize == null) {\n      // We don't have a block size yet (an empty file). The first\n      // write MUST be the beginning of the file. This is a new file\n      // and the first block contains the page size which we need.\n      // sqlite will write this block first, and if you are directly\n      // writing a db file to disk you can't write random parts of it.\n      // Just write the whole thing and we'll get the first block\n      // first.\n\n      let pageSize = getPageSize(new Uint8Array(bufferView.buffer, bufferView.byteOffset + offset));\n\n      // Page sizes must be a power of 2 between 512 and 65536.\n      // These was generated by doing `Math.pow(2, N)` where N >= 9\n      // and N <= 16.\n      if (![512, 1024, 2048, 4096, 8192, 16384, 32768, 65536].includes(pageSize)) {\n        throw new Error('File has invalid page size. (the first block of a new file must be written first)');\n      }\n      this.setattr({\n        blockSize: pageSize\n      });\n    }\n    let buffer = bufferView.buffer;\n    if (length <= 0) {\n      return 0;\n    }\n    if (position < 0) {\n      return 0;\n    }\n    if (buffer.byteLength === 0) {\n      return 0;\n    }\n    length = Math.min(length, buffer.byteLength - offset);\n    let writes = writeChunks(new Uint8Array(buffer, offset, length), this.meta.blockSize, position, position + length);\n\n    // Find any partial chunks and read them in and merge with\n    // existing data\n    let {\n      partialWrites,\n      fullWrites\n    } = writes.reduce((state, write) => {\n      if (write.length !== this.meta.blockSize) {\n        state.partialWrites.push(write);\n      } else {\n        state.fullWrites.push({\n          pos: write.pos,\n          data: write.data\n        });\n      }\n      return state;\n    }, {\n      fullWrites: [],\n      partialWrites: []\n    });\n    let reads = [];\n    if (partialWrites.length > 0) {\n      reads = this.load(partialWrites.map(w => w.pos));\n    }\n    let allWrites = fullWrites.concat(reads.map(read => {\n      let write = partialWrites.find(w => w.pos === read.pos);\n\n      // MuTatIoN!\n      new Uint8Array(read.data).set(new Uint8Array(write.data, write.offset, write.length), write.offset, write.length);\n      return read;\n    }));\n    this.bufferChunks(allWrites);\n    if (position + length > this.meta.size) {\n      this.setattr({\n        size: position + length\n      });\n    }\n    return length;\n  }\n  async readIfFallback() {\n    if (this.ops.readIfFallback) {\n      // Reset the meta\n      let meta = await this.ops.readIfFallback();\n      this.meta = meta || {\n        size: 0\n      };\n    }\n  }\n  lock(lockType) {\n    // TODO: Perf APIs need improvement\n    if (!this._recordingLock) {\n      this._recordingLock = true;\n    }\n    if (this.ops.lock(lockType)) {\n      if (lockType >= LOCK_TYPES.RESERVED) {\n        this.writeLock = true;\n      }\n      return true;\n    }\n    return false;\n  }\n  unlock(lockType) {\n    if (lockType === 0) {\n      this._recordingLock = false;\n    }\n    if (this.writeLock) {\n      // In certain cases (I saw this while running VACUUM after\n      // changing page size) sqlite changes the size of the file\n      // _after_ `fsync` for some reason. In our case, this is\n      // critical because we are relying on fsync to write everything\n      // out. If we just did some writes, do another fsync which will\n      // check the meta and make sure it's persisted if dirty (all\n      // other writes should already be flushed by now)\n      this.fsync();\n      this.writeLock = false;\n    }\n    return this.ops.unlock(lockType);\n  }\n  fsync() {\n    if (this.buffer.size > 0) {\n      // We need to handle page size changes which restructures the\n      // whole db. We check if the page size is being written and\n      // handle it\n      let first = this.buffer.get(0);\n      if (first) {\n        let pageSize = getPageSize(new Uint8Array(first.data));\n        if (pageSize !== this.meta.blockSize) {\n          // The page size changed! We need to reflect that in our\n          // storage. We need to restructure all pending writes and\n          // change our page size so all future writes reflect the new\n          // size.\n          let buffer = this.buffer;\n          this.buffer = new Map();\n\n          // We take all pending writes, concat them into a single\n          // buffer, and rewrite it out with the new size. This would\n          // be dangerous if the page size could be changed at any\n          // point in time since we don't handle partial reads here.\n          // However sqlite only ever actually changes the page size\n          // in 2 cases:\n          //\n          // * The db is empty (no data yet, so nothing to read)\n          // * A VACUUM command is rewriting the entire db\n          //\n          // In both cases, we can assume we have _all_ the needed\n          // data in the pending buffer, and we don't have to worry\n          // about overwriting anything.\n\n          let writes = [...buffer.values()];\n          let totalSize = writes.length * this.meta.blockSize;\n          let buf = new ArrayBuffer(totalSize);\n          let view = new Uint8Array(buf);\n          for (let write of writes) {\n            view.set(new Uint8Array(write.data), write.pos);\n          }\n\n          // Rewrite the buffer with the new page size\n          this.bufferChunks(writeChunks(view, pageSize, 0, totalSize));\n\n          // Change our page size\n          this.setattr({\n            blockSize: pageSize\n          });\n        }\n      }\n      this.ops.writeBlocks([...this.buffer.values()], this.meta.blockSize);\n    }\n    if (this._metaDirty) {\n      // We only store the size right now. Block size is already\n      // stored in the sqlite file and we don't need the rest\n      //\n      // TODO: Currently we don't delete any extra blocks after the\n      // end of the file. This isn't super important, and in fact\n      // could cause perf regressions (sqlite doesn't compress files\n      // either!) but what we probably should do is detect a VACUUM\n      // command (the whole db is being rewritten) and at that point\n      // delete anything after the end of the file\n      this.ops.writeMeta({\n        size: this.meta.size\n      });\n      this._metaDirty = false;\n    }\n    this.buffer = new Map();\n  }\n  setattr(attr) {\n    if (this.meta == null) {\n      this.meta = {};\n    }\n\n    // Size is the only attribute we actually persist. The rest are\n    // stored in memory\n\n    if (attr.mode !== undefined) {\n      this.meta.mode = attr.mode;\n    }\n    if (attr.blockSize !== undefined) {\n      this.meta.blockSize = attr.blockSize;\n    }\n    if (attr.size !== undefined) {\n      this.meta.size = attr.size;\n      this._metaDirty = true;\n    }\n  }\n  getattr() {\n    return this.meta;\n  }\n}\nlet FINALIZED = 0xdeadbeef;\nlet WRITEABLE = 0;\nlet READABLE = 1;\nclass Reader {\n  constructor(buffer, {\n    initialOffset = 4,\n    useAtomics = true,\n    stream = true,\n    debug,\n    name\n  } = {}) {\n    this.buffer = buffer;\n    this.atomicView = new Int32Array(buffer);\n    this.offset = initialOffset;\n    this.useAtomics = useAtomics;\n    this.stream = stream;\n    this.debug = debug;\n    this.name = name;\n  }\n  log(...args) {\n    if (this.debug) {\n      console.log(`[reader: ${this.name}]`, ...args);\n    }\n  }\n  waitWrite(name, timeout = null) {\n    if (this.useAtomics) {\n      this.log(`waiting for ${name}`);\n      while (Atomics.load(this.atomicView, 0) === WRITEABLE) {\n        if (timeout != null) {\n          if (Atomics.wait(this.atomicView, 0, WRITEABLE, timeout) === 'timed-out') {\n            throw new Error('timeout');\n          }\n        }\n        Atomics.wait(this.atomicView, 0, WRITEABLE, 500);\n      }\n      this.log(`resumed for ${name}`);\n    } else {\n      if (this.atomicView[0] !== READABLE) {\n        throw new Error('`waitWrite` expected array to be readable');\n      }\n    }\n  }\n  flip() {\n    this.log('flip');\n    if (this.useAtomics) {\n      let prev = Atomics.compareExchange(this.atomicView, 0, READABLE, WRITEABLE);\n      if (prev !== READABLE) {\n        throw new Error('Read data out of sync! This is disastrous');\n      }\n      Atomics.notify(this.atomicView, 0);\n    } else {\n      this.atomicView[0] = WRITEABLE;\n    }\n    this.offset = 4;\n  }\n  done() {\n    this.waitWrite('done');\n    let dataView = new DataView(this.buffer, this.offset);\n    let done = dataView.getUint32(0) === FINALIZED;\n    if (done) {\n      this.log('done');\n      this.flip();\n    }\n    return done;\n  }\n  peek(fn) {\n    this.peekOffset = this.offset;\n    let res = fn();\n    this.offset = this.peekOffset;\n    this.peekOffset = null;\n    return res;\n  }\n  string(timeout) {\n    this.waitWrite('string', timeout);\n    let byteLength = this._int32();\n    let length = byteLength / 2;\n    let dataView = new DataView(this.buffer, this.offset, byteLength);\n    let chars = [];\n    for (let i = 0; i < length; i++) {\n      chars.push(dataView.getUint16(i * 2));\n    }\n    let str = String.fromCharCode.apply(null, chars);\n    this.log('string', str);\n    this.offset += byteLength;\n    if (this.peekOffset == null) {\n      this.flip();\n    }\n    return str;\n  }\n  _int32() {\n    let byteLength = 4;\n    let dataView = new DataView(this.buffer, this.offset);\n    let num = dataView.getInt32();\n    this.log('_int32', num);\n    this.offset += byteLength;\n    return num;\n  }\n  int32() {\n    this.waitWrite('int32');\n    let num = this._int32();\n    this.log('int32', num);\n    if (this.peekOffset == null) {\n      this.flip();\n    }\n    return num;\n  }\n  bytes() {\n    this.waitWrite('bytes');\n    let byteLength = this._int32();\n    let bytes = new ArrayBuffer(byteLength);\n    new Uint8Array(bytes).set(new Uint8Array(this.buffer, this.offset, byteLength));\n    this.log('bytes', bytes);\n    this.offset += byteLength;\n    if (this.peekOffset == null) {\n      this.flip();\n    }\n    return bytes;\n  }\n}\nclass Writer {\n  constructor(buffer, {\n    initialOffset = 4,\n    useAtomics = true,\n    stream = true,\n    debug,\n    name\n  } = {}) {\n    this.buffer = buffer;\n    this.atomicView = new Int32Array(buffer);\n    this.offset = initialOffset;\n    this.useAtomics = useAtomics;\n    this.stream = stream;\n    this.debug = debug;\n    this.name = name;\n    if (this.useAtomics) {\n      // The buffer starts out as writeable\n      Atomics.store(this.atomicView, 0, WRITEABLE);\n    } else {\n      this.atomicView[0] = WRITEABLE;\n    }\n  }\n  log(...args) {\n    if (this.debug) {\n      console.log(`[writer: ${this.name}]`, ...args);\n    }\n  }\n  waitRead(name) {\n    if (this.useAtomics) {\n      this.log(`waiting for ${name}`);\n      // Switch to writable\n      // Atomics.store(this.atomicView, 0, 1);\n\n      let prev = Atomics.compareExchange(this.atomicView, 0, WRITEABLE, READABLE);\n      if (prev !== WRITEABLE) {\n        throw new Error('Wrote something into unwritable buffer! This is disastrous');\n      }\n      Atomics.notify(this.atomicView, 0);\n      while (Atomics.load(this.atomicView, 0) === READABLE) {\n        // console.log('waiting to be read...');\n        Atomics.wait(this.atomicView, 0, READABLE, 500);\n      }\n      this.log(`resumed for ${name}`);\n    } else {\n      this.atomicView[0] = READABLE;\n    }\n    this.offset = 4;\n  }\n  finalize() {\n    this.log('finalizing');\n    let dataView = new DataView(this.buffer, this.offset);\n    dataView.setUint32(0, FINALIZED);\n    this.waitRead('finalize');\n  }\n  string(str) {\n    this.log('string', str);\n    let byteLength = str.length * 2;\n    this._int32(byteLength);\n    let dataView = new DataView(this.buffer, this.offset, byteLength);\n    for (let i = 0; i < str.length; i++) {\n      dataView.setUint16(i * 2, str.charCodeAt(i));\n    }\n    this.offset += byteLength;\n    this.waitRead('string');\n  }\n  _int32(num) {\n    let byteLength = 4;\n    let dataView = new DataView(this.buffer, this.offset);\n    dataView.setInt32(0, num);\n    this.offset += byteLength;\n  }\n  int32(num) {\n    this.log('int32', num);\n    this._int32(num);\n    this.waitRead('int32');\n  }\n  bytes(buffer) {\n    this.log('bytes', buffer);\n    let byteLength = buffer.byteLength;\n    this._int32(byteLength);\n    new Uint8Array(this.buffer, this.offset).set(new Uint8Array(buffer));\n    this.offset += byteLength;\n    this.waitRead('bytes');\n  }\n}\nfunction positionToKey$1(pos, blockSize) {\n  // We are forced to round because of floating point error. `pos`\n  // should always be divisible by `blockSize`\n  return Math.round(pos / blockSize);\n}\nfunction startWorker(reader, writer) {\n  // In a normal world, we'd spawn the worker here as a child worker.\n  // However Safari doesn't support nested workers, so we have to\n  // proxy them through the main thread\n  self.postMessage({\n    type: '__absurd:spawn-idb-worker',\n    argBuffer: writer.buffer,\n    resultBuffer: reader.buffer\n  });\n  self.addEventListener('message', e => {\n    switch (e.data.type) {\n      // Normally you would use `postMessage` control the profiler in\n      // a worker (just like this worker go those events), and the\n      // perf library automatically handles those events. We don't do\n      // that for the special backend worker though because it's\n      // always blocked when it's not processing. Instead we forward\n      // these events by going through the atomics layer to unblock it\n      // to make sure it starts immediately\n      case '__perf-deets:start-profile':\n        writer.string('profile-start');\n        writer.finalize();\n        reader.int32();\n        reader.done();\n        break;\n      case '__perf-deets:stop-profile':\n        writer.string('profile-stop');\n        writer.finalize();\n        reader.int32();\n        reader.done();\n        break;\n    }\n  });\n}\nclass FileOps {\n  constructor(filename) {\n    this.filename = filename;\n  }\n\n  // TODO: This should be renamed to `getDatabaseName`\n  getStoreName() {\n    return this.filename.replace(/\\//g, '-');\n  }\n  invokeWorker(method, args) {\n    if (this.reader == null || this.writer == null) {\n      throw new Error(`Attempted ${method} on ${this.filename} but file not open`);\n    }\n    let reader = this.reader;\n    let writer = this.writer;\n    switch (method) {\n      case 'readBlocks':\n        {\n          let {\n            name,\n            positions,\n            blockSize\n          } = args;\n          let res = [];\n          for (let pos of positions) {\n            writer.string('readBlock');\n            writer.string(name);\n            writer.int32(positionToKey$1(pos, blockSize));\n            writer.finalize();\n            let data = reader.bytes();\n            reader.done();\n            res.push({\n              pos,\n              // If th length is 0, the block didn't exist. We return a\n              // blank block in that case\n              data: data.byteLength === 0 ? new ArrayBuffer(blockSize) : data\n            });\n          }\n          return res;\n        }\n      case 'writeBlocks':\n        {\n          let {\n            name,\n            writes,\n            blockSize\n          } = args;\n          writer.string('writeBlocks');\n          writer.string(name);\n          for (let write of writes) {\n            writer.int32(positionToKey$1(write.pos, blockSize));\n            writer.bytes(write.data);\n          }\n          writer.finalize();\n          let res = reader.int32();\n          reader.done();\n          return res;\n        }\n      case 'readMeta':\n        {\n          writer.string('readMeta');\n          writer.string(args.name);\n          writer.finalize();\n          let size = reader.int32();\n          let blockSize = reader.int32();\n          reader.done();\n          return size === -1 ? null : {\n            size,\n            blockSize\n          };\n        }\n      case 'writeMeta':\n        {\n          let {\n            name,\n            meta\n          } = args;\n          writer.string('writeMeta');\n          writer.string(name);\n          writer.int32(meta.size);\n          // writer.int32(meta.blockSize);\n          writer.finalize();\n          let res = reader.int32();\n          reader.done();\n          return res;\n        }\n      case 'closeFile':\n        {\n          writer.string('closeFile');\n          writer.string(args.name);\n          writer.finalize();\n          let res = reader.int32();\n          reader.done();\n          return res;\n        }\n      case 'lockFile':\n        {\n          writer.string('lockFile');\n          writer.string(args.name);\n          writer.int32(args.lockType);\n          writer.finalize();\n          let res = reader.int32();\n          reader.done();\n          return res === 0;\n        }\n      case 'unlockFile':\n        {\n          writer.string('unlockFile');\n          writer.string(args.name);\n          writer.int32(args.lockType);\n          writer.finalize();\n          let res = reader.int32();\n          reader.done();\n          return res === 0;\n        }\n    }\n  }\n  lock(lockType) {\n    return this.invokeWorker('lockFile', {\n      name: this.getStoreName(),\n      lockType\n    });\n  }\n  unlock(lockType) {\n    return this.invokeWorker('unlockFile', {\n      name: this.getStoreName(),\n      lockType\n    });\n  }\n  delete() {\n    // Close the file if it's open\n    if (this.reader || this.writer) {\n      this.close();\n    }\n\n    // We delete it here because we can't do it in the worker; the\n    // worker is stopped when the file closes. If we didn't do that,\n    // workers would leak in the case of closing a file but not\n    // deleting it. We could potentially restart the worker here if\n    // needed, but for now just assume that the deletion is a success\n    let req = globalThis.indexedDB.deleteDatabase(this.getStoreName());\n    req.onerror = () => {\n      console.warn(`Deleting ${this.filename} database failed`);\n    };\n    req.onsuccess = () => {};\n  }\n  open() {\n    let argBuffer = new SharedArrayBuffer(4096 * 9);\n    this.writer = new Writer(argBuffer, {\n      name: 'args (backend)',\n      debug: false\n    });\n    let resultBuffer = new SharedArrayBuffer(4096 * 9);\n    this.reader = new Reader(resultBuffer, {\n      name: 'results',\n      debug: false\n    });\n\n    // TODO: We could pool workers and reuse them so opening files\n    // aren't so slow\n    startWorker(this.reader, this.writer);\n  }\n  close() {\n    this.invokeWorker('closeFile', {\n      name: this.getStoreName()\n    });\n    this.reader = null;\n    this.writer = null;\n    this.worker = null;\n  }\n  readMeta() {\n    return this.invokeWorker('readMeta', {\n      name: this.getStoreName()\n    });\n  }\n  writeMeta(meta) {\n    return this.invokeWorker('writeMeta', {\n      name: this.getStoreName(),\n      meta\n    });\n  }\n  readBlocks(positions, blockSize) {\n    if (this.stats) {\n      this.stats.read += positions.length;\n    }\n    return this.invokeWorker('readBlocks', {\n      name: this.getStoreName(),\n      positions,\n      blockSize\n    });\n  }\n  writeBlocks(writes, blockSize) {\n    if (this.stats) {\n      this.stats.writes += writes.length;\n    }\n    return this.invokeWorker('writeBlocks', {\n      name: this.getStoreName(),\n      writes,\n      blockSize\n    });\n  }\n}\n\n/**\n * https://bugs.webkit.org/show_bug.cgi?id=226547\n * Safari has a horrible bug where IDB requests can hang while the browser is starting up.\n * The only solution is to keep nudging it until it's awake.\n * This probably creates garbage, but garbage is better than totally failing.\n */\nfunction idbReady() {\n  const isSafari = !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent);\n  // No point putting other browsers or older versions of Safari through this mess.\n  if (!isSafari || !indexedDB.databases) return Promise.resolve();\n  let intervalId;\n  return new Promise(resolve => {\n    const tryIdb = () => indexedDB.databases().finally(resolve);\n    intervalId = setInterval(tryIdb, 100);\n    tryIdb();\n  }).finally(() => clearInterval(intervalId));\n}\nfunction positionToKey(pos, blockSize) {\n  // We are forced to round because of floating point error. `pos`\n  // should always be divisible by `blockSize`\n  return Math.round(pos / blockSize);\n}\nasync function openDb(name) {\n  await idbReady();\n  return new Promise((resolve, reject) => {\n    let req = globalThis.indexedDB.open(name, 2);\n    req.onsuccess = event => {\n      let db = event.target.result;\n      db.onversionchange = () => {\n        console.log('closing because version changed');\n        db.close();\n      };\n      db.onclose = () => {};\n      resolve(db);\n    };\n    req.onupgradeneeded = event => {\n      let db = event.target.result;\n      if (!db.objectStoreNames.contains('data')) {\n        db.createObjectStore('data');\n      }\n    };\n    req.onblocked = e => console.log('blocked', e);\n    req.onerror = req.onabort = e => reject(e.target.error);\n  });\n}\n\n// Using a separate class makes it easier to follow the code, and\n// importantly it removes any reliance on internal state in\n// `FileOpsFallback`. That would be problematic since these method\n// happen async; the args to `write` must be closed over so they don't\n// change\nclass Persistance {\n  constructor(dbName, onFallbackFailure) {\n    this.dbName = dbName;\n    this._openDb = null;\n    this.hasAlertedFailure = false;\n    this.onFallbackFailure = onFallbackFailure;\n  }\n  async getDb() {\n    if (this._openDb) {\n      return this._openDb;\n    }\n    this._openDb = await openDb(this.dbName);\n    return this._openDb;\n  }\n  closeDb() {\n    if (this._openDb) {\n      this._openDb.close();\n      this._openDb = null;\n    }\n  }\n\n  // Both `readAll` and `write` rely on IndexedDB transactional\n  // semantics to work, otherwise we'd have to coordinate them. If\n  // there are pending writes, the `readonly` transaction in `readAll`\n  // will block until they are all flushed out. If `write` is called\n  // multiple times, `readwrite` transactions can only run one at a\n  // time so it will naturally apply the writes sequentially (and\n  // atomically)\n\n  async readAll() {\n    let db = await this.getDb(this.dbName);\n    let blocks = new Map();\n    let trans = db.transaction(['data'], 'readonly');\n    let store = trans.objectStore('data');\n    return new Promise((resolve, reject) => {\n      // Open a cursor and iterate through the entire file\n      let req = store.openCursor(IDBKeyRange.lowerBound(-1));\n      req.onerror = reject;\n      req.onsuccess = e => {\n        let cursor = e.target.result;\n        if (cursor) {\n          blocks.set(cursor.key, cursor.value);\n          cursor.continue();\n        } else {\n          resolve(blocks);\n        }\n      };\n    });\n  }\n  async write(writes, cachedFirstBlock, hasLocked) {\n    let db = await this.getDb(this.dbName);\n\n    // We need grab a readwrite lock on the db, and then read to check\n    // to make sure we can write to it\n    let trans = db.transaction(['data'], 'readwrite');\n    let store = trans.objectStore('data');\n    await new Promise((resolve, reject) => {\n      let req = store.get(0);\n      req.onsuccess = e => {\n        if (hasLocked) {\n          if (!isSafeToWrite(req.result, cachedFirstBlock)) {\n            if (this.onFallbackFailure && !this.hasAlertedFailure) {\n              this.hasAlertedFailure = true;\n              this.onFallbackFailure();\n            }\n            reject(new Error('Fallback mode unable to write file changes'));\n            return;\n          }\n        }\n\n        // Flush all the writes\n        for (let write of writes) {\n          store.put(write.value, write.key);\n        }\n        trans.onsuccess = () => resolve();\n        trans.onerror = () => reject();\n      };\n      req.onerror = reject;\n    });\n  }\n}\nclass FileOpsFallback {\n  constructor(filename, onFallbackFailure) {\n    this.filename = filename;\n    this.dbName = this.filename.replace(/\\//g, '-');\n    this.cachedFirstBlock = null;\n    this.writeQueue = null;\n    this.blocks = new Map();\n    this.lockType = 0;\n    this.transferBlockOwnership = false;\n    this.persistance = new Persistance(this.dbName, onFallbackFailure);\n  }\n  async readIfFallback() {\n    this.transferBlockOwnership = true;\n    this.blocks = await this.persistance.readAll();\n    return this.readMeta();\n  }\n  lock(lockType) {\n    // Locks always succeed here. Essentially we're only working\n    // locally (we can't see any writes from anybody else) and we just\n    // want to track the lock so we know when it downgrades from write\n    // to read\n    this.cachedFirstBlock = this.blocks.get(0);\n    this.lockType = lockType;\n    return true;\n  }\n  unlock(lockType) {\n    if (this.lockType > LOCK_TYPES.SHARED && lockType === LOCK_TYPES.SHARED) {\n      // Within a write lock, we delay all writes until the end of the\n      // lock. We probably don't have to do this since we already\n      // delay writes until an `fsync`, however this is an extra\n      // measure to make sure we are writing everything atomically\n      this.flush();\n    }\n    this.lockType = lockType;\n    return true;\n  }\n  delete() {\n    let req = globalThis.indexedDB.deleteDatabase(this.dbName);\n    req.onerror = () => {\n      console.warn(`Deleting ${this.filename} database failed`);\n    };\n    req.onsuccess = () => {};\n  }\n  open() {\n    this.writeQueue = [];\n    this.lockType = 0;\n  }\n  close() {\n    this.flush();\n    if (this.transferBlockOwnership) {\n      this.transferBlockOwnership = false;\n    } else {\n      this.blocks = new Map();\n    }\n    this.persistance.closeDb();\n  }\n  readMeta() {\n    let metaBlock = this.blocks.get(-1);\n    if (metaBlock) {\n      let block = this.blocks.get(0);\n      return {\n        size: metaBlock.size,\n        blockSize: getPageSize(new Uint8Array(block))\n      };\n    }\n    return null;\n  }\n  writeMeta(meta) {\n    this.blocks.set(-1, meta);\n    this.queueWrite(-1, meta);\n  }\n  readBlocks(positions, blockSize) {\n    let res = [];\n    for (let pos of positions) {\n      res.push({\n        pos,\n        data: this.blocks.get(positionToKey(pos, blockSize))\n      });\n    }\n    return res;\n  }\n  writeBlocks(writes, blockSize) {\n    for (let write of writes) {\n      let key = positionToKey(write.pos, blockSize);\n      this.blocks.set(key, write.data);\n      this.queueWrite(key, write.data);\n    }\n\n    // No write lock; flush them out immediately\n    if (this.lockType <= LOCK_TYPES.SHARED) {\n      this.flush();\n    }\n  }\n  queueWrite(key, value) {\n    this.writeQueue.push({\n      key,\n      value\n    });\n  }\n  flush() {\n    if (this.writeQueue.length > 0) {\n      this.persistance.write(this.writeQueue, this.cachedFirstBlock, this.lockType > LOCK_TYPES.SHARED);\n      this.writeQueue = [];\n    }\n    this.cachedFirstBlock = null;\n  }\n}\nclass IndexedDBBackend {\n  constructor(onFallbackFailure) {\n    this.onFallbackFailure = onFallbackFailure;\n  }\n  createFile(filename) {\n    let ops;\n    if (typeof SharedArrayBuffer !== 'undefined') {\n      // SharedArrayBuffer exists! We can run this fully\n      ops = new FileOps(filename);\n    } else {\n      // SharedArrayBuffer is not supported. Use the fallback methods\n      // which provide a somewhat working version, but doesn't\n      // support mutations across connections (tabs)\n      ops = new FileOpsFallback(filename, this.onFallbackFailure);\n    }\n    let file = new File(filename, ops);\n\n    // If we don't need perf data, there's no reason for us to hold a\n    // reference to the files. If we did we'd have to worry about\n    // memory leaks\n    if (process.env.NODE_ENV !== 'production' || process.env.PERF_BUILD) {\n      if (this._files == null) {\n        this._files = new Set();\n      }\n      this._files.add(file);\n    }\n    return file;\n  }\n\n  // Instead of controlling the profiler from the main thread by\n  // posting a message to this worker, you can control it inside the\n  // worker manually with these methods\n  startProfile() {\n    for (let file of this._files) {\n      // If the writer doesn't exist, that means the file has been\n      // deleted\n      if (file.ops.writer) {\n        let writer = file.ops.writer;\n        let reader = file.ops.reader;\n        writer.string('profile-start');\n        writer.finalize();\n        reader.int32();\n        reader.done();\n      }\n    }\n  }\n  stopProfile() {\n    for (let file of this._files) {\n      if (file.ops.writer) {\n        let writer = file.ops.writer;\n        let reader = file.ops.reader;\n        writer.string('profile-stop');\n        writer.finalize();\n        reader.int32();\n        reader.done();\n      }\n    }\n  }\n}\nexport default IndexedDBBackend;","map":{"version":3,"names":["LOCK_TYPES","NONE","SHARED","RESERVED","PENDING","EXCLUSIVE","getPageSize","bufferView","int1","int2","isSafeToWrite","localData","diskData","localView","Uint8Array","diskView","i","range","start","end","step","r","push","getBoundaryIndexes","blockSize","startC","endC","readChunks","chunks","buffer","ArrayBuffer","length","chunk","data","constructor","name","Error","cstart","cend","byteLength","pos","len","set","writeChunks","indexes","cursor","map","index","chunkBuffer","off","byteOffset","available","readLength","Math","min","offset","filter","Boolean","File","filename","ops","meta","Map","_metaDirty","writeLock","openHandles","bufferChunks","open","readMeta","size","close","fsync","max","delete","load","status","reduce","acc","b","inMemory","get","missing","missingChunks","readBlocks","concat","read","position","view","dataLength","readBuffer","write","pageSize","includes","setattr","writes","partialWrites","fullWrites","state","reads","w","allWrites","find","readIfFallback","lock","lockType","_recordingLock","unlock","first","values","totalSize","buf","writeBlocks","writeMeta","attr","mode","undefined","getattr","FINALIZED","WRITEABLE","READABLE","Reader","initialOffset","useAtomics","stream","debug","atomicView","Int32Array","log","args","console","waitWrite","timeout","Atomics","wait","flip","prev","compareExchange","notify","done","dataView","DataView","getUint32","peek","fn","peekOffset","res","string","_int32","chars","getUint16","str","String","fromCharCode","apply","num","getInt32","int32","bytes","Writer","store","waitRead","finalize","setUint32","setUint16","charCodeAt","setInt32","positionToKey$1","round","startWorker","reader","writer","self","postMessage","type","argBuffer","resultBuffer","addEventListener","e","FileOps","getStoreName","replace","invokeWorker","method","positions","req","globalThis","indexedDB","deleteDatabase","onerror","warn","onsuccess","SharedArrayBuffer","worker","stats","idbReady","isSafari","navigator","userAgentData","test","userAgent","databases","Promise","resolve","intervalId","tryIdb","finally","setInterval","clearInterval","positionToKey","openDb","reject","event","db","target","result","onversionchange","onclose","onupgradeneeded","objectStoreNames","contains","createObjectStore","onblocked","onabort","error","Persistance","dbName","onFallbackFailure","_openDb","hasAlertedFailure","getDb","closeDb","readAll","blocks","trans","transaction","objectStore","openCursor","IDBKeyRange","lowerBound","key","value","continue","cachedFirstBlock","hasLocked","put","FileOpsFallback","writeQueue","transferBlockOwnership","persistance","flush","metaBlock","block","queueWrite","IndexedDBBackend","createFile","file","process","env","NODE_ENV","PERF_BUILD","_files","Set","add","startProfile","stopProfile"],"sources":["C:/ysx/xm/mark/web/node_modules/absurd-sql-optimized/dist/indexeddb-backend.js"],"sourcesContent":["let LOCK_TYPES = {\n  NONE: 0,\n  SHARED: 1,\n  RESERVED: 2,\n  PENDING: 3,\n  EXCLUSIVE: 4\n};\n\nfunction getPageSize(bufferView) {\n  // See 1.3.2 on https://www.sqlite.org/fileformat.html The page size\n  // is stored as a 2 byte integer at the 16th byte. It's stored as\n  // big-endian so the first byte is the larger one. Combine it into a\n  // single integer.\n  let int1 = bufferView[16];\n  let int2 = bufferView[17];\n  return (int1 << 8) + int2;\n}\n\nfunction isSafeToWrite(localData, diskData) {\n  if (localData != null && diskData != null) {\n    let localView = new Uint8Array(localData);\n    let diskView = new Uint8Array(diskData);\n\n    // See\n    // https://github.com/sqlite/sqlite/blob/master/src/pager.c#L93-L96\n    // (might be documented somewhere? I didn't see it this clearly in\n    // the docs). At least one of these bytes change when sqlite3 writes\n    // data. We can check this against our in-memory data to see if it's\n    // safe to write (if something changes underneath us, it's not)\n    for (let i = 24; i < 40; i++) {\n      if (localView[i] !== diskView[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // One of them is null, so it's only safe if to write if both are\n  // null, otherwise they are different\n  return localData == null && diskData == null;\n}\n\nfunction range(start, end, step) {\n  let r = [];\n  for (let i = start; i <= end; i += step) {\n    r.push(i);\n  }\n  return r;\n}\n\nfunction getBoundaryIndexes(blockSize, start, end) {\n  let startC = start - (start % blockSize);\n  let endC = end - 1 - ((end - 1) % blockSize);\n\n  return range(startC, endC, blockSize);\n}\n\nfunction readChunks(chunks, start, end) {\n  let buffer = new ArrayBuffer(end - start);\n  let bufferView = new Uint8Array(buffer);\n  for (let i = 0; i < chunks.length; i++) {\n    let chunk = chunks[i];\n\n    // TODO: jest has a bug where we can't do `instanceof ArrayBuffer`\n    if (chunk.data.constructor.name !== 'ArrayBuffer') {\n      throw new Error('Chunk data is not an ArrayBuffer');\n    }\n\n    let cstart = 0;\n    let cend = chunk.data.byteLength;\n\n    if (start > chunk.pos) {\n      cstart = start - chunk.pos;\n    }\n    if (end < chunk.pos + chunk.data.byteLength) {\n      cend = end - chunk.pos;\n    }\n\n    if (cstart > chunk.data.byteLength || cend < 0) {\n      continue;\n    }\n\n    let len = cend - cstart;\n\n    bufferView.set(\n      new Uint8Array(chunk.data, cstart, len),\n      chunk.pos - start + cstart\n    );\n  }\n\n  return buffer;\n}\n\nfunction writeChunks(bufferView, blockSize, start, end) {\n  let indexes = getBoundaryIndexes(blockSize, start, end);\n  let cursor = 0;\n\n  return indexes\n    .map(index => {\n      let cstart = 0;\n      let cend = blockSize;\n      if (start > index && start < index + blockSize) {\n        cstart = start - index;\n      }\n      if (end > index && end < index + blockSize) {\n        cend = end - index;\n      }\n\n      let len = cend - cstart;\n      let chunkBuffer = new ArrayBuffer(blockSize);\n\n      if (start > index + blockSize || end <= index) {\n        return null;\n      }\n\n      let off = bufferView.byteOffset + cursor;\n\n      let available = bufferView.buffer.byteLength - off;\n      if (available <= 0) {\n        return null;\n      }\n\n      let readLength = Math.min(len, available);\n\n      new Uint8Array(chunkBuffer).set(\n        new Uint8Array(bufferView.buffer, off, readLength),\n        cstart\n      );\n      cursor += readLength;\n\n      return {\n        pos: index,\n        data: chunkBuffer,\n        offset: cstart,\n        length: readLength\n      };\n    })\n    .filter(Boolean);\n}\n\nclass File {\n  constructor(filename, ops, meta = null) {\n    this.filename = filename;\n    this.buffer = new Map();\n    this.ops = ops;\n    this.meta = meta;\n    this._metaDirty = false;\n    this.writeLock = false;\n    this.openHandles = 0;\n  }\n\n  bufferChunks(chunks) {\n    for (let i = 0; i < chunks.length; i++) {\n      let chunk = chunks[i];\n      this.buffer.set(chunk.pos, chunk);\n    }\n  }\n\n  open() {\n    this.openHandles++;\n\n    // Don't open the file again if it's already open\n    if (this.openHandles === 1) {\n      this.ops.open();\n      let meta = this.ops.readMeta();\n\n      // It's possible that `setattr` has already been called if opening\n      // the file in a mode that truncates it to 0\n      if (this.meta == null) {\n        if (meta == null) {\n          // New file\n\n          meta = { size: 0 };\n        }\n\n        this.meta = meta;\n      }\n    }\n\n    return this.meta;\n  }\n\n  close() {\n    this.fsync();\n\n    this.openHandles = Math.max(this.openHandles - 1, 0);\n\n    // Only close it if there are no existing open handles\n    if (this.openHandles === 0) {\n      this.ops.close();\n    }\n  }\n\n  delete() {\n    this.ops.delete();\n  }\n\n  load(indexes) {\n    let status = indexes.reduce(\n      (acc, b) => {\n        let inMemory = this.buffer.get(b);\n        if (inMemory) {\n          acc.chunks.push(inMemory);\n        } else {\n          acc.missing.push(b);\n        }\n        return acc;\n      },\n      { chunks: [], missing: [] }\n    );\n\n    let missingChunks = [];\n    if (status.missing.length > 0) {\n      missingChunks = this.ops.readBlocks(status.missing, this.meta.blockSize);\n    }\n    return status.chunks.concat(missingChunks);\n  }\n\n  read(bufferView, offset, length, position) {\n    // console.log('reading', this.filename, offset, length, position);\n    let buffer = bufferView.buffer;\n\n    if (length <= 0) {\n      return 0;\n    }\n    if (position < 0) {\n      // TODO: is this right?\n      return 0;\n    }\n    if (position >= this.meta.size) {\n      let view = new Uint8Array(buffer, offset);\n      for (let i = 0; i < length; i++) {\n        view[i] = 0;\n      }\n\n      return length;\n    }\n\n    position = Math.max(position, 0);\n    let dataLength = Math.min(length, this.meta.size - position);\n\n    let start = position;\n    let end = position + dataLength;\n\n    let indexes = getBoundaryIndexes(this.meta.blockSize, start, end);\n\n    let chunks = this.load(indexes);\n    let readBuffer = readChunks(chunks, start, end);\n\n    if (buffer.byteLength - offset < readBuffer.byteLength) {\n      throw new Error('Buffer given to `read` is too small');\n    }\n    let view = new Uint8Array(buffer);\n    view.set(new Uint8Array(readBuffer), offset);\n\n    // TODO: I don't need to do this. `unixRead` does this for us.\n    for (let i = dataLength; i < length; i++) {\n      view[offset + i] = 0;\n    }\n\n    return length;\n  }\n\n  write(bufferView, offset, length, position) {\n    // console.log('writing', this.filename, offset, length, position);\n\n    if (this.meta.blockSize == null) {\n      // We don't have a block size yet (an empty file). The first\n      // write MUST be the beginning of the file. This is a new file\n      // and the first block contains the page size which we need.\n      // sqlite will write this block first, and if you are directly\n      // writing a db file to disk you can't write random parts of it.\n      // Just write the whole thing and we'll get the first block\n      // first.\n\n      let pageSize = getPageSize(\n        new Uint8Array(bufferView.buffer, bufferView.byteOffset + offset)\n      );\n\n      // Page sizes must be a power of 2 between 512 and 65536.\n      // These was generated by doing `Math.pow(2, N)` where N >= 9\n      // and N <= 16.\n      if (\n        ![512, 1024, 2048, 4096, 8192, 16384, 32768, 65536].includes(pageSize)\n      ) {\n        throw new Error(\n          'File has invalid page size. (the first block of a new file must be written first)'\n        );\n      }\n\n      this.setattr({ blockSize: pageSize });\n    }\n\n    let buffer = bufferView.buffer;\n\n    if (length <= 0) {\n      return 0;\n    }\n    if (position < 0) {\n      return 0;\n    }\n    if (buffer.byteLength === 0) {\n      return 0;\n    }\n\n    length = Math.min(length, buffer.byteLength - offset);\n\n    let writes = writeChunks(\n      new Uint8Array(buffer, offset, length),\n      this.meta.blockSize,\n      position,\n      position + length\n    );\n\n    // Find any partial chunks and read them in and merge with\n    // existing data\n    let { partialWrites, fullWrites } = writes.reduce(\n      (state, write) => {\n        if (write.length !== this.meta.blockSize) {\n          state.partialWrites.push(write);\n        } else {\n          state.fullWrites.push({\n            pos: write.pos,\n            data: write.data\n          });\n        }\n        return state;\n      },\n      { fullWrites: [], partialWrites: [] }\n    );\n\n    let reads = [];\n    if (partialWrites.length > 0) {\n      reads = this.load(partialWrites.map(w => w.pos));\n    }\n\n    let allWrites = fullWrites.concat(\n      reads.map(read => {\n        let write = partialWrites.find(w => w.pos === read.pos);\n\n        // MuTatIoN!\n        new Uint8Array(read.data).set(\n          new Uint8Array(write.data, write.offset, write.length),\n          write.offset,\n          write.length\n        );\n\n        return read;\n      })\n    );\n\n    this.bufferChunks(allWrites);\n\n    if (position + length > this.meta.size) {\n      this.setattr({ size: position + length });\n    }\n\n    return length;\n  }\n\n  async readIfFallback() {\n    if (this.ops.readIfFallback) {\n      // Reset the meta\n      let meta = await this.ops.readIfFallback();\n      this.meta = meta || { size: 0 };\n    }\n  }\n\n  lock(lockType) {\n    // TODO: Perf APIs need improvement\n    if (!this._recordingLock) {\n      this._recordingLock = true;\n    }\n\n    if (this.ops.lock(lockType)) {\n      if (lockType >= LOCK_TYPES.RESERVED) {\n        this.writeLock = true;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  unlock(lockType) {\n    if (lockType === 0) {\n      this._recordingLock = false;\n    }\n\n    if (this.writeLock) {\n      // In certain cases (I saw this while running VACUUM after\n      // changing page size) sqlite changes the size of the file\n      // _after_ `fsync` for some reason. In our case, this is\n      // critical because we are relying on fsync to write everything\n      // out. If we just did some writes, do another fsync which will\n      // check the meta and make sure it's persisted if dirty (all\n      // other writes should already be flushed by now)\n      this.fsync();\n      this.writeLock = false;\n    }\n\n    return this.ops.unlock(lockType);\n  }\n\n  fsync() {\n    if (this.buffer.size > 0) {\n      // We need to handle page size changes which restructures the\n      // whole db. We check if the page size is being written and\n      // handle it\n      let first = this.buffer.get(0);\n      if (first) {\n        let pageSize = getPageSize(new Uint8Array(first.data));\n\n        if (pageSize !== this.meta.blockSize) {\n          // The page size changed! We need to reflect that in our\n          // storage. We need to restructure all pending writes and\n          // change our page size so all future writes reflect the new\n          // size.\n          let buffer = this.buffer;\n          this.buffer = new Map();\n\n          // We take all pending writes, concat them into a single\n          // buffer, and rewrite it out with the new size. This would\n          // be dangerous if the page size could be changed at any\n          // point in time since we don't handle partial reads here.\n          // However sqlite only ever actually changes the page size\n          // in 2 cases:\n          //\n          // * The db is empty (no data yet, so nothing to read)\n          // * A VACUUM command is rewriting the entire db\n          //\n          // In both cases, we can assume we have _all_ the needed\n          // data in the pending buffer, and we don't have to worry\n          // about overwriting anything.\n\n          let writes = [...buffer.values()];\n          let totalSize = writes.length * this.meta.blockSize;\n          let buf = new ArrayBuffer(totalSize);\n          let view = new Uint8Array(buf);\n\n          for (let write of writes) {\n            view.set(new Uint8Array(write.data), write.pos);\n          }\n\n          // Rewrite the buffer with the new page size\n          this.bufferChunks(writeChunks(view, pageSize, 0, totalSize));\n\n          // Change our page size\n          this.setattr({ blockSize: pageSize });\n        }\n      }\n\n      this.ops.writeBlocks([...this.buffer.values()], this.meta.blockSize);\n    }\n\n    if (this._metaDirty) {\n      // We only store the size right now. Block size is already\n      // stored in the sqlite file and we don't need the rest\n      //\n      // TODO: Currently we don't delete any extra blocks after the\n      // end of the file. This isn't super important, and in fact\n      // could cause perf regressions (sqlite doesn't compress files\n      // either!) but what we probably should do is detect a VACUUM\n      // command (the whole db is being rewritten) and at that point\n      // delete anything after the end of the file\n      this.ops.writeMeta({ size: this.meta.size });\n      this._metaDirty = false;\n    }\n\n    this.buffer = new Map();\n  }\n\n  setattr(attr) {\n    if (this.meta == null) {\n      this.meta = {};\n    }\n\n    // Size is the only attribute we actually persist. The rest are\n    // stored in memory\n\n    if (attr.mode !== undefined) {\n      this.meta.mode = attr.mode;\n    }\n\n    if (attr.blockSize !== undefined) {\n      this.meta.blockSize = attr.blockSize;\n    }\n\n    if (attr.size !== undefined) {\n      this.meta.size = attr.size;\n      this._metaDirty = true;\n    }\n  }\n\n  getattr() {\n    return this.meta;\n  }\n}\n\nlet FINALIZED = 0xdeadbeef;\n\nlet WRITEABLE = 0;\nlet READABLE = 1;\n\nclass Reader {\n  constructor(\n    buffer,\n    { initialOffset = 4, useAtomics = true, stream = true, debug, name } = {}\n  ) {\n    this.buffer = buffer;\n    this.atomicView = new Int32Array(buffer);\n    this.offset = initialOffset;\n    this.useAtomics = useAtomics;\n    this.stream = stream;\n    this.debug = debug;\n    this.name = name;\n  }\n\n  log(...args) {\n    if (this.debug) {\n      console.log(`[reader: ${this.name}]`, ...args);\n    }\n  }\n\n  waitWrite(name, timeout = null) {\n    if (this.useAtomics) {\n      this.log(`waiting for ${name}`);\n\n      while (Atomics.load(this.atomicView, 0) === WRITEABLE) {\n        if (timeout != null) {\n          if (\n            Atomics.wait(this.atomicView, 0, WRITEABLE, timeout) === 'timed-out'\n          ) {\n            throw new Error('timeout');\n          }\n        }\n\n        Atomics.wait(this.atomicView, 0, WRITEABLE, 500);\n      }\n\n      this.log(`resumed for ${name}`);\n    } else {\n      if (this.atomicView[0] !== READABLE) {\n        throw new Error('`waitWrite` expected array to be readable');\n      }\n    }\n  }\n\n  flip() {\n    this.log('flip');\n    if (this.useAtomics) {\n      let prev = Atomics.compareExchange(\n        this.atomicView,\n        0,\n        READABLE,\n        WRITEABLE\n      );\n\n      if (prev !== READABLE) {\n        throw new Error('Read data out of sync! This is disastrous');\n      }\n\n      Atomics.notify(this.atomicView, 0);\n    } else {\n      this.atomicView[0] = WRITEABLE;\n    }\n\n    this.offset = 4;\n  }\n\n  done() {\n    this.waitWrite('done');\n\n    let dataView = new DataView(this.buffer, this.offset);\n    let done = dataView.getUint32(0) === FINALIZED;\n\n    if (done) {\n      this.log('done');\n      this.flip();\n    }\n\n    return done;\n  }\n\n  peek(fn) {\n    this.peekOffset = this.offset;\n    let res = fn();\n    this.offset = this.peekOffset;\n    this.peekOffset = null;\n    return res;\n  }\n\n  string(timeout) {\n    this.waitWrite('string', timeout);\n\n    let byteLength = this._int32();\n    let length = byteLength / 2;\n\n    let dataView = new DataView(this.buffer, this.offset, byteLength);\n    let chars = [];\n    for (let i = 0; i < length; i++) {\n      chars.push(dataView.getUint16(i * 2));\n    }\n    let str = String.fromCharCode.apply(null, chars);\n    this.log('string', str);\n\n    this.offset += byteLength;\n\n    if (this.peekOffset == null) {\n      this.flip();\n    }\n    return str;\n  }\n\n  _int32() {\n    let byteLength = 4;\n\n    let dataView = new DataView(this.buffer, this.offset);\n    let num = dataView.getInt32();\n    this.log('_int32', num);\n\n    this.offset += byteLength;\n    return num;\n  }\n\n  int32() {\n    this.waitWrite('int32');\n    let num = this._int32();\n    this.log('int32', num);\n\n    if (this.peekOffset == null) {\n      this.flip();\n    }\n    return num;\n  }\n\n  bytes() {\n    this.waitWrite('bytes');\n\n    let byteLength = this._int32();\n\n    let bytes = new ArrayBuffer(byteLength);\n    new Uint8Array(bytes).set(\n      new Uint8Array(this.buffer, this.offset, byteLength)\n    );\n    this.log('bytes', bytes);\n\n    this.offset += byteLength;\n\n    if (this.peekOffset == null) {\n      this.flip();\n    }\n    return bytes;\n  }\n}\n\nclass Writer {\n  constructor(\n    buffer,\n    { initialOffset = 4, useAtomics = true, stream = true, debug, name } = {}\n  ) {\n    this.buffer = buffer;\n    this.atomicView = new Int32Array(buffer);\n    this.offset = initialOffset;\n    this.useAtomics = useAtomics;\n    this.stream = stream;\n\n    this.debug = debug;\n    this.name = name;\n\n    if (this.useAtomics) {\n      // The buffer starts out as writeable\n      Atomics.store(this.atomicView, 0, WRITEABLE);\n    } else {\n      this.atomicView[0] = WRITEABLE;\n    }\n  }\n\n  log(...args) {\n    if (this.debug) {\n      console.log(`[writer: ${this.name}]`, ...args);\n    }\n  }\n\n  waitRead(name) {\n    if (this.useAtomics) {\n      this.log(`waiting for ${name}`);\n      // Switch to writable\n      // Atomics.store(this.atomicView, 0, 1);\n\n      let prev = Atomics.compareExchange(\n        this.atomicView,\n        0,\n        WRITEABLE,\n        READABLE\n      );\n\n      if (prev !== WRITEABLE) {\n        throw new Error(\n          'Wrote something into unwritable buffer! This is disastrous'\n        );\n      }\n\n      Atomics.notify(this.atomicView, 0);\n\n      while (Atomics.load(this.atomicView, 0) === READABLE) {\n        // console.log('waiting to be read...');\n        Atomics.wait(this.atomicView, 0, READABLE, 500);\n      }\n\n      this.log(`resumed for ${name}`);\n    } else {\n      this.atomicView[0] = READABLE;\n    }\n\n    this.offset = 4;\n  }\n\n  finalize() {\n    this.log('finalizing');\n    let dataView = new DataView(this.buffer, this.offset);\n    dataView.setUint32(0, FINALIZED);\n    this.waitRead('finalize');\n  }\n\n  string(str) {\n    this.log('string', str);\n\n    let byteLength = str.length * 2;\n    this._int32(byteLength);\n\n    let dataView = new DataView(this.buffer, this.offset, byteLength);\n    for (let i = 0; i < str.length; i++) {\n      dataView.setUint16(i * 2, str.charCodeAt(i));\n    }\n\n    this.offset += byteLength;\n    this.waitRead('string');\n  }\n\n  _int32(num) {\n    let byteLength = 4;\n\n    let dataView = new DataView(this.buffer, this.offset);\n    dataView.setInt32(0, num);\n\n    this.offset += byteLength;\n  }\n\n  int32(num) {\n    this.log('int32', num);\n    this._int32(num);\n    this.waitRead('int32');\n  }\n\n  bytes(buffer) {\n    this.log('bytes', buffer);\n\n    let byteLength = buffer.byteLength;\n    this._int32(byteLength);\n    new Uint8Array(this.buffer, this.offset).set(new Uint8Array(buffer));\n\n    this.offset += byteLength;\n    this.waitRead('bytes');\n  }\n}\n\nfunction positionToKey$1(pos, blockSize) {\n  // We are forced to round because of floating point error. `pos`\n  // should always be divisible by `blockSize`\n  return Math.round(pos / blockSize);\n}\n\nfunction startWorker(reader, writer) {\n  // In a normal world, we'd spawn the worker here as a child worker.\n  // However Safari doesn't support nested workers, so we have to\n  // proxy them through the main thread\n  self.postMessage({\n    type: '__absurd:spawn-idb-worker',\n    argBuffer: writer.buffer,\n    resultBuffer: reader.buffer\n  });\n\n  self.addEventListener('message', e => {\n    switch (e.data.type) {\n      // Normally you would use `postMessage` control the profiler in\n      // a worker (just like this worker go those events), and the\n      // perf library automatically handles those events. We don't do\n      // that for the special backend worker though because it's\n      // always blocked when it's not processing. Instead we forward\n      // these events by going through the atomics layer to unblock it\n      // to make sure it starts immediately\n      case '__perf-deets:start-profile':\n        writer.string('profile-start');\n        writer.finalize();\n        reader.int32();\n        reader.done();\n        break;\n\n      case '__perf-deets:stop-profile':\n        writer.string('profile-stop');\n        writer.finalize();\n        reader.int32();\n        reader.done();\n        break;\n    }\n  });\n}\n\nclass FileOps {\n  constructor(filename) {\n    this.filename = filename;\n  }\n\n  // TODO: This should be renamed to `getDatabaseName`\n  getStoreName() {\n    return this.filename.replace(/\\//g, '-');\n  }\n\n  invokeWorker(method, args) {\n    if (this.reader == null || this.writer == null) {\n      throw new Error(\n        `Attempted ${method} on ${this.filename} but file not open`\n      );\n    }\n\n    let reader = this.reader;\n    let writer = this.writer;\n\n    switch (method) {\n      case 'readBlocks': {\n        let { name, positions, blockSize } = args;\n\n        let res = [];\n        for (let pos of positions) {\n          writer.string('readBlock');\n          writer.string(name);\n          writer.int32(positionToKey$1(pos, blockSize));\n          writer.finalize();\n\n          let data = reader.bytes();\n          reader.done();\n          res.push({\n            pos,\n            // If th length is 0, the block didn't exist. We return a\n            // blank block in that case\n            data: data.byteLength === 0 ? new ArrayBuffer(blockSize) : data\n          });\n        }\n\n        return res;\n      }\n\n      case 'writeBlocks': {\n        let { name, writes, blockSize } = args;\n        writer.string('writeBlocks');\n        writer.string(name);\n        for (let write of writes) {\n          writer.int32(positionToKey$1(write.pos, blockSize));\n          writer.bytes(write.data);\n        }\n        writer.finalize();\n\n        let res = reader.int32();\n        reader.done();\n        return res;\n      }\n\n      case 'readMeta': {\n        writer.string('readMeta');\n        writer.string(args.name);\n        writer.finalize();\n\n        let size = reader.int32();\n        let blockSize = reader.int32();\n        reader.done();\n        return size === -1 ? null : { size, blockSize };\n      }\n\n      case 'writeMeta': {\n        let { name, meta } = args;\n        writer.string('writeMeta');\n        writer.string(name);\n        writer.int32(meta.size);\n        // writer.int32(meta.blockSize);\n        writer.finalize();\n\n        let res = reader.int32();\n        reader.done();\n        return res;\n      }\n\n      case 'closeFile': {\n        writer.string('closeFile');\n        writer.string(args.name);\n        writer.finalize();\n\n        let res = reader.int32();\n        reader.done();\n        return res;\n      }\n\n      case 'lockFile': {\n        writer.string('lockFile');\n        writer.string(args.name);\n        writer.int32(args.lockType);\n        writer.finalize();\n\n        let res = reader.int32();\n        reader.done();\n        return res === 0;\n      }\n\n      case 'unlockFile': {\n        writer.string('unlockFile');\n        writer.string(args.name);\n        writer.int32(args.lockType);\n        writer.finalize();\n\n        let res = reader.int32();\n        reader.done();\n        return res === 0;\n      }\n    }\n  }\n\n  lock(lockType) {\n    return this.invokeWorker('lockFile', {\n      name: this.getStoreName(),\n      lockType\n    });\n  }\n\n  unlock(lockType) {\n    return this.invokeWorker('unlockFile', {\n      name: this.getStoreName(),\n      lockType\n    });\n  }\n\n  delete() {\n    // Close the file if it's open\n    if (this.reader || this.writer) {\n      this.close();\n    }\n\n    // We delete it here because we can't do it in the worker; the\n    // worker is stopped when the file closes. If we didn't do that,\n    // workers would leak in the case of closing a file but not\n    // deleting it. We could potentially restart the worker here if\n    // needed, but for now just assume that the deletion is a success\n    let req = globalThis.indexedDB.deleteDatabase(this.getStoreName());\n    req.onerror = () => {\n      console.warn(`Deleting ${this.filename} database failed`);\n    };\n    req.onsuccess = () => {};\n  }\n\n  open() {\n    let argBuffer = new SharedArrayBuffer(4096 * 9);\n    this.writer = new Writer(argBuffer, {\n      name: 'args (backend)',\n      debug: false\n    });\n\n    let resultBuffer = new SharedArrayBuffer(4096 * 9);\n    this.reader = new Reader(resultBuffer, {\n      name: 'results',\n      debug: false\n    });\n\n    // TODO: We could pool workers and reuse them so opening files\n    // aren't so slow\n    startWorker(this.reader, this.writer);\n  }\n\n  close() {\n    this.invokeWorker('closeFile', { name: this.getStoreName() });\n    this.reader = null;\n    this.writer = null;\n    this.worker = null;\n  }\n\n  readMeta() {\n    return this.invokeWorker('readMeta', { name: this.getStoreName() });\n  }\n\n  writeMeta(meta) {\n    return this.invokeWorker('writeMeta', { name: this.getStoreName(), meta });\n  }\n\n  readBlocks(positions, blockSize) {\n    if (this.stats) {\n      this.stats.read += positions.length;\n    }\n\n    return this.invokeWorker('readBlocks', {\n      name: this.getStoreName(),\n      positions,\n      blockSize\n    });\n  }\n\n  writeBlocks(writes, blockSize) {\n    if (this.stats) {\n      this.stats.writes += writes.length;\n    }\n\n    return this.invokeWorker('writeBlocks', {\n      name: this.getStoreName(),\n      writes,\n      blockSize\n    });\n  }\n}\n\n/**\n * https://bugs.webkit.org/show_bug.cgi?id=226547\n * Safari has a horrible bug where IDB requests can hang while the browser is starting up.\n * The only solution is to keep nudging it until it's awake.\n * This probably creates garbage, but garbage is better than totally failing.\n */\nfunction idbReady() {\n    const isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    // No point putting other browsers or older versions of Safari through this mess.\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    let intervalId;\n    return new Promise((resolve) => {\n        const tryIdb = () => indexedDB.databases().finally(resolve);\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(() => clearInterval(intervalId));\n}\n\nfunction positionToKey(pos, blockSize) {\n  // We are forced to round because of floating point error. `pos`\n  // should always be divisible by `blockSize`\n  return Math.round(pos / blockSize);\n}\n\nasync function openDb(name) {\n  await idbReady();\n\n  return new Promise((resolve, reject) => {\n    let req = globalThis.indexedDB.open(name, 2);\n    req.onsuccess = event => {\n      let db = event.target.result;\n\n      db.onversionchange = () => {\n        console.log('closing because version changed');\n        db.close();\n      };\n      db.onclose = () => {};\n\n      resolve(db);\n    };\n    req.onupgradeneeded = event => {\n      let db = event.target.result;\n      if (!db.objectStoreNames.contains('data')) {\n        db.createObjectStore('data');\n      }\n    };\n    req.onblocked = e => console.log('blocked', e);\n    req.onerror = req.onabort = e => reject(e.target.error);\n  });\n}\n\n// Using a separate class makes it easier to follow the code, and\n// importantly it removes any reliance on internal state in\n// `FileOpsFallback`. That would be problematic since these method\n// happen async; the args to `write` must be closed over so they don't\n// change\nclass Persistance {\n  constructor(dbName, onFallbackFailure) {\n    this.dbName = dbName;\n    this._openDb = null;\n    this.hasAlertedFailure = false;\n    this.onFallbackFailure = onFallbackFailure;\n  }\n\n  async getDb() {\n    if (this._openDb) {\n      return this._openDb;\n    }\n\n    this._openDb = await openDb(this.dbName);\n    return this._openDb;\n  }\n\n  closeDb() {\n    if (this._openDb) {\n      this._openDb.close();\n      this._openDb = null;\n    }\n  }\n\n  // Both `readAll` and `write` rely on IndexedDB transactional\n  // semantics to work, otherwise we'd have to coordinate them. If\n  // there are pending writes, the `readonly` transaction in `readAll`\n  // will block until they are all flushed out. If `write` is called\n  // multiple times, `readwrite` transactions can only run one at a\n  // time so it will naturally apply the writes sequentially (and\n  // atomically)\n\n  async readAll() {\n    let db = await this.getDb(this.dbName);\n    let blocks = new Map();\n\n    let trans = db.transaction(['data'], 'readonly');\n    let store = trans.objectStore('data');\n\n    return new Promise((resolve, reject) => {\n      // Open a cursor and iterate through the entire file\n      let req = store.openCursor(IDBKeyRange.lowerBound(-1));\n      req.onerror = reject;\n      req.onsuccess = e => {\n        let cursor = e.target.result;\n        if (cursor) {\n          blocks.set(cursor.key, cursor.value);\n          cursor.continue();\n        } else {\n          resolve(blocks);\n        }\n      };\n    });\n  }\n\n  async write(writes, cachedFirstBlock, hasLocked) {\n    let db = await this.getDb(this.dbName);\n\n    // We need grab a readwrite lock on the db, and then read to check\n    // to make sure we can write to it\n    let trans = db.transaction(['data'], 'readwrite');\n    let store = trans.objectStore('data');\n\n    await new Promise((resolve, reject) => {\n      let req = store.get(0);\n      req.onsuccess = e => {\n        if (hasLocked) {\n          if (!isSafeToWrite(req.result, cachedFirstBlock)) {\n            if (this.onFallbackFailure && !this.hasAlertedFailure) {\n              this.hasAlertedFailure = true;\n              this.onFallbackFailure();\n            }\n            reject(new Error('Fallback mode unable to write file changes'));\n            return;\n          }\n        }\n\n        // Flush all the writes\n        for (let write of writes) {\n          store.put(write.value, write.key);\n        }\n\n        trans.onsuccess = () => resolve();\n        trans.onerror = () => reject();\n      };\n      req.onerror = reject;\n    });\n  }\n}\n\nclass FileOpsFallback {\n  constructor(filename, onFallbackFailure) {\n    this.filename = filename;\n    this.dbName = this.filename.replace(/\\//g, '-');\n    this.cachedFirstBlock = null;\n    this.writeQueue = null;\n    this.blocks = new Map();\n    this.lockType = 0;\n    this.transferBlockOwnership = false;\n\n    this.persistance = new Persistance(this.dbName, onFallbackFailure);\n  }\n\n  async readIfFallback() {\n    this.transferBlockOwnership = true;\n    this.blocks = await this.persistance.readAll();\n\n    return this.readMeta();\n  }\n\n  lock(lockType) {\n    // Locks always succeed here. Essentially we're only working\n    // locally (we can't see any writes from anybody else) and we just\n    // want to track the lock so we know when it downgrades from write\n    // to read\n    this.cachedFirstBlock = this.blocks.get(0);\n    this.lockType = lockType;\n    return true;\n  }\n\n  unlock(lockType) {\n    if (this.lockType > LOCK_TYPES.SHARED && lockType === LOCK_TYPES.SHARED) {\n      // Within a write lock, we delay all writes until the end of the\n      // lock. We probably don't have to do this since we already\n      // delay writes until an `fsync`, however this is an extra\n      // measure to make sure we are writing everything atomically\n      this.flush();\n    }\n    this.lockType = lockType;\n    return true;\n  }\n\n  delete() {\n    let req = globalThis.indexedDB.deleteDatabase(this.dbName);\n    req.onerror = () => {\n      console.warn(`Deleting ${this.filename} database failed`);\n    };\n    req.onsuccess = () => {};\n  }\n\n  open() {\n    this.writeQueue = [];\n    this.lockType = 0;\n  }\n\n  close() {\n    this.flush();\n\n    if (this.transferBlockOwnership) {\n      this.transferBlockOwnership = false;\n    } else {\n      this.blocks = new Map();\n    }\n\n    this.persistance.closeDb();\n  }\n\n  readMeta() {\n    let metaBlock = this.blocks.get(-1);\n    if (metaBlock) {\n      let block = this.blocks.get(0);\n\n      return {\n        size: metaBlock.size,\n        blockSize: getPageSize(new Uint8Array(block))\n      };\n    }\n    return null;\n  }\n\n  writeMeta(meta) {\n    this.blocks.set(-1, meta);\n    this.queueWrite(-1, meta);\n  }\n\n  readBlocks(positions, blockSize) {\n    let res = [];\n    for (let pos of positions) {\n      res.push({\n        pos,\n        data: this.blocks.get(positionToKey(pos, blockSize))\n      });\n    }\n    return res;\n  }\n\n  writeBlocks(writes, blockSize) {\n    for (let write of writes) {\n      let key = positionToKey(write.pos, blockSize);\n      this.blocks.set(key, write.data);\n      this.queueWrite(key, write.data);\n    }\n\n    // No write lock; flush them out immediately\n    if (this.lockType <= LOCK_TYPES.SHARED) {\n      this.flush();\n    }\n  }\n\n  queueWrite(key, value) {\n    this.writeQueue.push({ key, value });\n  }\n\n  flush() {\n    if (this.writeQueue.length > 0) {\n      this.persistance.write(\n        this.writeQueue,\n        this.cachedFirstBlock,\n        this.lockType > LOCK_TYPES.SHARED\n      );\n      this.writeQueue = [];\n    }\n    this.cachedFirstBlock = null;\n  }\n}\n\nclass IndexedDBBackend {\n  constructor(onFallbackFailure) {\n    this.onFallbackFailure = onFallbackFailure;\n  }\n\n  createFile(filename) {\n    let ops;\n    if (typeof SharedArrayBuffer !== 'undefined') {\n      // SharedArrayBuffer exists! We can run this fully\n      ops = new FileOps(filename);\n    } else {\n      // SharedArrayBuffer is not supported. Use the fallback methods\n      // which provide a somewhat working version, but doesn't\n      // support mutations across connections (tabs)\n      ops = new FileOpsFallback(filename, this.onFallbackFailure);\n    }\n\n    let file = new File(filename, ops);\n\n    // If we don't need perf data, there's no reason for us to hold a\n    // reference to the files. If we did we'd have to worry about\n    // memory leaks\n    if (process.env.NODE_ENV !== 'production' || process.env.PERF_BUILD) {\n      if (this._files == null) {\n        this._files = new Set();\n      }\n      this._files.add(file);\n    }\n\n    return file;\n  }\n\n  // Instead of controlling the profiler from the main thread by\n  // posting a message to this worker, you can control it inside the\n  // worker manually with these methods\n  startProfile() {\n    for (let file of this._files) {\n      // If the writer doesn't exist, that means the file has been\n      // deleted\n      if (file.ops.writer) {\n        let writer = file.ops.writer;\n        let reader = file.ops.reader;\n        writer.string('profile-start');\n        writer.finalize();\n        reader.int32();\n        reader.done();\n      }\n    }\n  }\n\n  stopProfile() {\n    for (let file of this._files) {\n      if (file.ops.writer) {\n        let writer = file.ops.writer;\n        let reader = file.ops.reader;\n        writer.string('profile-stop');\n        writer.finalize();\n        reader.int32();\n        reader.done();\n      }\n    }\n  }\n}\n\nexport default IndexedDBBackend;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}